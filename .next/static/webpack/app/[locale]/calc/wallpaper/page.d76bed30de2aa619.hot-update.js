"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[locale]/calc/wallpaper/page",{

/***/ "(app-pages-browser)/./src/lib/calculators/wallpaper.ts":
/*!******************************************!*\
  !*** ./src/lib/calculators/wallpaper.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDoor: function() { return /* binding */ addDoor; },\n/* harmony export */   addWindow: function() { return /* binding */ addWindow; },\n/* harmony export */   calculateWallpaper: function() { return /* binding */ calculateWallpaper; },\n/* harmony export */   formatWallpaperArea: function() { return /* binding */ formatWallpaperArea; },\n/* harmony export */   formatWallpaperNumber: function() { return /* binding */ formatWallpaperNumber; },\n/* harmony export */   getStandardReservePercentages: function() { return /* binding */ getStandardReservePercentages; },\n/* harmony export */   getStandardRollSizes: function() { return /* binding */ getStandardRollSizes; },\n/* harmony export */   removeDoor: function() { return /* binding */ removeDoor; },\n/* harmony export */   removeWindow: function() { return /* binding */ removeWindow; },\n/* harmony export */   updateDoor: function() { return /* binding */ updateDoor; },\n/* harmony export */   updateWindow: function() { return /* binding */ updateWindow; },\n/* harmony export */   validateWallpaperInput: function() { return /* binding */ validateWallpaperInput; }\n/* harmony export */ });\n// Wallpaper calculation logic and interfaces\nfunction calculateWallpaper(input) {\n    const { roomLength, roomWidth, wallHeight, rollWidth, rollLength, doors, windows, reservePercentage } = input;\n    // Calculate total wall area\n    // Formula: 2 × (Length + Width) × Height\n    const totalWallArea = 2 * (roomLength + roomWidth) * wallHeight;\n    // Calculate doors area\n    const doorsArea = doors.reduce((total, door)=>{\n        return total + door.width * door.height;\n    }, 0);\n    // Calculate windows area\n    const windowsArea = windows.reduce((total, window)=>{\n        return total + window.width * window.height;\n    }, 0);\n    // Total openings area\n    const openingsArea = doorsArea + windowsArea;\n    // Useful wall area (after subtracting openings)\n    const usefulWallArea = Math.max(0, totalWallArea - openingsArea);\n    // Calculate roll area\n    const rollArea = rollWidth * rollLength;\n    // Calculate reserve area\n    const reserveArea = usefulWallArea * (reservePercentage / 100);\n    // Total area needed (useful area + reserve)\n    const totalAreaNeeded = usefulWallArea + reserveArea;\n    // Calculate number of rolls needed\n    const rollsNeeded = Math.ceil(totalAreaNeeded / rollArea);\n    // Recommended rolls (add 1 extra for pattern matching and future repairs)\n    const recommendedRolls = rollsNeeded + 1;\n    return {\n        // Room dimensions\n        roomLength: Math.round(roomLength * 100) / 100,\n        roomWidth: Math.round(roomWidth * 100) / 100,\n        wallHeight: Math.round(wallHeight * 100) / 100,\n        // Wall area calculations\n        totalWallArea: Math.round(totalWallArea * 100) / 100,\n        doorsArea: Math.round(doorsArea * 100) / 100,\n        windowsArea: Math.round(windowsArea * 100) / 100,\n        openingsArea: Math.round(openingsArea * 100) / 100,\n        usefulWallArea: Math.round(usefulWallArea * 100) / 100,\n        // Roll calculations\n        rollWidth: Math.round(rollWidth * 100) / 100,\n        rollLength: Math.round(rollLength * 100) / 100,\n        rollArea: Math.round(rollArea * 100) / 100,\n        // Reserve and final calculations\n        reservePercentage: Math.round(reservePercentage * 100) / 100,\n        reserveArea: Math.round(reserveArea * 100) / 100,\n        totalAreaNeeded: Math.round(totalAreaNeeded * 100) / 100,\n        rollsNeeded: Math.round(rollsNeeded),\n        recommendedRolls: Math.round(recommendedRolls),\n        // Additional info\n        doorsCount: doors.length,\n        windowsCount: windows.length\n    };\n}\nfunction validateWallpaperInput(input) {\n    const errors = [];\n    // Room dimensions validation\n    if (!input.roomLength || input.roomLength <= 0) {\n        errors.push(\"Длина комнаты должна быть больше 0\");\n    }\n    if (input.roomLength && input.roomLength > 100) {\n        errors.push(\"Длина комнаты не может быть больше 100 метров\");\n    }\n    if (!input.roomWidth || input.roomWidth <= 0) {\n        errors.push(\"Ширина комнаты должна быть больше 0\");\n    }\n    if (input.roomWidth && input.roomWidth > 100) {\n        errors.push(\"Ширина комнаты не может быть больше 100 метров\");\n    }\n    if (!input.wallHeight || input.wallHeight <= 0) {\n        errors.push(\"Высота стен должна быть больше 0\");\n    }\n    if (input.wallHeight && input.wallHeight > 10) {\n        errors.push(\"Высота стен не может быть больше 10 метров\");\n    }\n    // Roll dimensions validation\n    if (!input.rollWidth || input.rollWidth <= 0) {\n        errors.push(\"Ширина рулона должна быть больше 0\");\n    }\n    if (input.rollWidth && input.rollWidth > 5) {\n        errors.push(\"Ширина рулона не может быть больше 5 метров\");\n    }\n    if (!input.rollLength || input.rollLength <= 0) {\n        errors.push(\"Длина рулона должна быть больше 0\");\n    }\n    if (input.rollLength && input.rollLength > 50) {\n        errors.push(\"Длина рулона не может быть больше 50 метров\");\n    }\n    // Reserve percentage validation\n    if (input.reservePercentage !== undefined && input.reservePercentage < 0) {\n        errors.push(\"Запас не может быть отрицательным\");\n    }\n    if (input.reservePercentage && input.reservePercentage > 100) {\n        errors.push(\"Запас не может быть больше 100%\");\n    }\n    // Doors and windows validation\n    if (input.doors) {\n        for(let i = 0; i < input.doors.length; i++){\n            const door = input.doors[i];\n            if (door.width <= 0 || door.height <= 0) {\n                errors.push(\"Дверь \".concat(i + 1, \": размеры должны быть больше 0\"));\n            }\n            if (door.width > 5 || door.height > 5) {\n                errors.push(\"Дверь \".concat(i + 1, \": размеры не могут быть больше 5 метров\"));\n            }\n        }\n    }\n    if (input.windows) {\n        for(let i = 0; i < input.windows.length; i++){\n            const window = input.windows[i];\n            if (window.width <= 0 || window.height <= 0) {\n                errors.push(\"Окно \".concat(i + 1, \": размеры должны быть больше 0\"));\n            }\n            if (window.width > 10 || window.height > 10) {\n                errors.push(\"Окно \".concat(i + 1, \": размеры не могут быть больше 10 метров\"));\n            }\n        }\n    }\n    return errors;\n}\nfunction formatWallpaperArea(area) {\n    return new Intl.NumberFormat(\"ru-RU\", {\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }).format(area) + \" м\\xb2\";\n}\nfunction formatWallpaperNumber(value) {\n    return new Intl.NumberFormat(\"ru-RU\", {\n        minimumFractionDigits: 0,\n        maximumFractionDigits: 2\n    }).format(value);\n}\nfunction getStandardRollSizes() {\n    return [\n        {\n            width: 0.53,\n            length: 10.05,\n            label: \"0.53 \\xd7 10.05 м\",\n            description: \"Стандартный размер (европейский)\"\n        },\n        {\n            width: 0.7,\n            length: 10.05,\n            label: \"0.7 \\xd7 10.05 м\",\n            description: \"Широкий рулон\"\n        },\n        {\n            width: 1.06,\n            length: 10.05,\n            label: \"1.06 \\xd7 10.05 м\",\n            description: \"Очень широкий рулон\"\n        },\n        {\n            width: 0.53,\n            length: 15.0,\n            label: \"0.53 \\xd7 15.0 м\",\n            description: \"Длинный рулон\"\n        },\n        {\n            width: 0.7,\n            length: 15.0,\n            label: \"0.7 \\xd7 15.0 м\",\n            description: \"Широкий длинный рулон\"\n        }\n    ];\n}\nfunction getStandardReservePercentages() {\n    return [\n        {\n            value: 5,\n            label: \"5%\",\n            description: \"Минимальный запас\"\n        },\n        {\n            value: 10,\n            label: \"10%\",\n            description: \"Стандартный запас\"\n        },\n        {\n            value: 15,\n            label: \"15%\",\n            description: \"Увеличенный запас\"\n        },\n        {\n            value: 20,\n            label: \"20%\",\n            description: \"Большой запас\"\n        }\n    ];\n}\nfunction addDoor(input) {\n    return {\n        ...input,\n        doors: [\n            ...input.doors,\n            {\n                width: 0.8,\n                height: 2.1\n            }\n        ]\n    };\n}\nfunction addWindow(input) {\n    return {\n        ...input,\n        windows: [\n            ...input.windows,\n            {\n                width: 1.2,\n                height: 1.5\n            }\n        ]\n    };\n}\nfunction removeDoor(input, index) {\n    const newDoors = input.doors.filter((_, i)=>i !== index);\n    return {\n        ...input,\n        doors: newDoors\n    };\n}\nfunction removeWindow(input, index) {\n    const newWindows = input.windows.filter((_, i)=>i !== index);\n    return {\n        ...input,\n        windows: newWindows\n    };\n}\nfunction updateDoor(input, index, door) {\n    const newDoors = [\n        ...input.doors\n    ];\n    newDoors[index] = door;\n    return {\n        ...input,\n        doors: newDoors\n    };\n}\nfunction updateWindow(input, index, window) {\n    const newWindows = [\n        ...input.windows\n    ];\n    newWindows[index] = window;\n    return {\n        ...input,\n        windows: newWindows\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY2FsY3VsYXRvcnMvd2FsbHBhcGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUE2QztBQWdEdEMsU0FBU0EsbUJBQW1CQyxLQUFxQjtJQUN2RCxNQUFNLEVBQ0xDLFVBQVUsRUFDVkMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxLQUFLLEVBQ0xDLE9BQU8sRUFDUEMsaUJBQWlCLEVBQ2pCLEdBQUdSO0lBRUosNEJBQTRCO0lBQzVCLHlDQUF5QztJQUN6QyxNQUFNUyxnQkFBZ0IsSUFBS1IsQ0FBQUEsYUFBYUMsU0FBUSxJQUFLQztJQUVyRCx1QkFBdUI7SUFDdkIsTUFBTU8sWUFBWUosTUFBTUssTUFBTSxDQUFDLENBQUNDLE9BQU9DO1FBQ3RDLE9BQU9ELFFBQVFDLEtBQUtDLEtBQUssR0FBR0QsS0FBS0UsTUFBTTtJQUN4QyxHQUFHO0lBRUgseUJBQXlCO0lBQ3pCLE1BQU1DLGNBQWNULFFBQVFJLE1BQU0sQ0FBQyxDQUFDQyxPQUFPSztRQUMxQyxPQUFPTCxRQUFRSyxPQUFPSCxLQUFLLEdBQUdHLE9BQU9GLE1BQU07SUFDNUMsR0FBRztJQUVILHNCQUFzQjtJQUN0QixNQUFNRyxlQUFlUixZQUFZTTtJQUVqQyxnREFBZ0Q7SUFDaEQsTUFBTUcsaUJBQWlCQyxLQUFLQyxHQUFHLENBQUMsR0FBR1osZ0JBQWdCUztJQUVuRCxzQkFBc0I7SUFDdEIsTUFBTUksV0FBV2xCLFlBQVlDO0lBRTdCLHlCQUF5QjtJQUN6QixNQUFNa0IsY0FBY0osaUJBQWtCWCxDQUFBQSxvQkFBb0IsR0FBRTtJQUU1RCw0Q0FBNEM7SUFDNUMsTUFBTWdCLGtCQUFrQkwsaUJBQWlCSTtJQUV6QyxtQ0FBbUM7SUFDbkMsTUFBTUUsY0FBY0wsS0FBS00sSUFBSSxDQUFDRixrQkFBa0JGO0lBRWhELDBFQUEwRTtJQUMxRSxNQUFNSyxtQkFBbUJGLGNBQWM7SUFFdkMsT0FB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Z0JBQUVPLE9BQU87Z0JBQUtDLFFBQVE7WUFBSTtTQUFFO0lBQ3pEO0FBQ0Q7QUFFTyxTQUFTcUMsV0FDZnBELEtBQXFCLEVBQ3JCcUQsS0FBYTtJQUViLE1BQU1DLFdBQVd0RCxNQUFNTSxLQUFLLENBQUNpRCxNQUFNLENBQUMsQ0FBQ0MsR0FBR3BCLElBQU1BLE1BQU1pQjtJQUNwRCxPQUFPO1FBQ04sR0FBR3JELEtBQUs7UUFDUk0sT0FBT2dEO0lBQ1I7QUFDRDtBQUVPLFNBQVNHLGFBQ2Z6RCxLQUFxQixFQUNyQnFELEtBQWE7SUFFYixNQUFNSyxhQUFhMUQsTUFBTU8sT0FBTyxDQUFDZ0QsTUFBTSxDQUFDLENBQUNDLEdBQUdwQixJQUFNQSxNQUFNaUI7SUFDeEQsT0FBTztRQUNOLEdBQUdyRCxLQUFLO1FBQ1JPLFNBQVNtRDtJQUNWO0FBQ0Q7QUFFTyxTQUFTQyxXQUNmM0QsS0FBcUIsRUFDckJxRCxLQUFhLEVBQ2J4QyxJQUFnQjtJQUVoQixNQUFNeUMsV0FBVztXQUFJdEQsTUFBTU0sS0FBSztLQUFDO0lBQ2pDZ0QsUUFBUSxDQUFDRCxNQUFNLEdBQUd4QztJQUNsQixPQUFPO1FBQ04sR0FBR2IsS0FBSztRQUNSTSxPQUFPZ0Q7SUFDUjtBQUNEO0FBRU8sU0FBU00sYUFDZjVELEtBQXFCLEVBQ3JCcUQsS0FBYSxFQUNicEMsTUFBa0I7SUFFbEIsTUFBTXlDLGFBQWE7V0FBSTFELE1BQU1PLE9BQU87S0FBQztJQUNyQ21ELFVBQVUsQ0FBQ0wsTUFBTSxHQUFHcEM7SUFDcEIsT0FBTztRQUNOLEdBQUdqQixLQUFLO1FBQ1JPLFNBQVNtRDtJQUNWO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9jYWxjdWxhdG9ycy93YWxscGFwZXIudHM/YWYxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXYWxscGFwZXIgY2FsY3VsYXRpb24gbG9naWMgYW5kIGludGVyZmFjZXNcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2FsbHBhcGVySW5wdXQge1xyXG5cdHJvb21MZW5ndGg6IG51bWJlcjsgLy8gUm9vbSBsZW5ndGggaW4gbWV0ZXJzXHJcblx0cm9vbVdpZHRoOiBudW1iZXI7IC8vIFJvb20gd2lkdGggaW4gbWV0ZXJzXHJcblx0d2FsbEhlaWdodDogbnVtYmVyOyAvLyBXYWxsIGhlaWdodCBpbiBtZXRlcnNcclxuXHRyb2xsV2lkdGg6IG51bWJlcjsgLy8gUm9sbCB3aWR0aCBpbiBtZXRlcnNcclxuXHRyb2xsTGVuZ3RoOiBudW1iZXI7IC8vIFJvbGwgbGVuZ3RoIGluIG1ldGVyc1xyXG5cdGRvb3JzOiBEb29yV2luZG93W107IC8vIEFycmF5IG9mIGRvb3JzXHJcblx0d2luZG93czogRG9vcldpbmRvd1tdOyAvLyBBcnJheSBvZiB3aW5kb3dzXHJcblx0cmVzZXJ2ZVBlcmNlbnRhZ2U6IG51bWJlcjsgLy8gUmVzZXJ2ZSBwZXJjZW50YWdlIChkZWZhdWx0IDEwJSlcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEb29yV2luZG93IHtcclxuXHR3aWR0aDogbnVtYmVyOyAvLyBXaWR0aCBpbiBtZXRlcnNcclxuXHRoZWlnaHQ6IG51bWJlcjsgLy8gSGVpZ2h0IGluIG1ldGVyc1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxwYXBlclJlc3VsdCB7XHJcblx0Ly8gUm9vbSBkaW1lbnNpb25zXHJcblx0cm9vbUxlbmd0aDogbnVtYmVyO1xyXG5cdHJvb21XaWR0aDogbnVtYmVyO1xyXG5cdHdhbGxIZWlnaHQ6IG51bWJlcjtcclxuXHJcblx0Ly8gV2FsbCBhcmVhIGNhbGN1bGF0aW9uc1xyXG5cdHRvdGFsV2FsbEFyZWE6IG51bWJlcjtcclxuXHRkb29yc0FyZWE6IG51bWJlcjtcclxuXHR3aW5kb3dzQXJlYTogbnVtYmVyO1xyXG5cdG9wZW5pbmdzQXJlYTogbnVtYmVyO1xyXG5cdHVzZWZ1bFdhbGxBcmVhOiBudW1iZXI7XHJcblxyXG5cdC8vIFJvbGwgY2FsY3VsYXRpb25zXHJcblx0cm9sbFdpZHRoOiBudW1iZXI7XHJcblx0cm9sbExlbmd0aDogbnVtYmVyO1xyXG5cdHJvbGxBcmVhOiBudW1iZXI7XHJcblxyXG5cdC8vIFJlc2VydmUgYW5kIGZpbmFsIGNhbGN1bGF0aW9uc1xyXG5cdHJlc2VydmVQZXJjZW50YWdlOiBudW1iZXI7XHJcblx0cmVzZXJ2ZUFyZWE6IG51bWJlcjtcclxuXHR0b3RhbEFyZWFOZWVkZWQ6IG51bWJlcjtcclxuXHRyb2xsc05lZWRlZDogbnVtYmVyO1xyXG5cdHJlY29tbWVuZGVkUm9sbHM6IG51bWJlcjtcclxuXHJcblx0Ly8gQWRkaXRpb25hbCBpbmZvXHJcblx0ZG9vcnNDb3VudDogbnVtYmVyO1xyXG5cdHdpbmRvd3NDb3VudDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlV2FsbHBhcGVyKGlucHV0OiBXYWxscGFwZXJJbnB1dCk6IFdhbGxwYXBlclJlc3VsdCB7XHJcblx0Y29uc3Qge1xyXG5cdFx0cm9vbUxlbmd0aCxcclxuXHRcdHJvb21XaWR0aCxcclxuXHRcdHdhbGxIZWlnaHQsXHJcblx0XHRyb2xsV2lkdGgsXHJcblx0XHRyb2xsTGVuZ3RoLFxyXG5cdFx0ZG9vcnMsXHJcblx0XHR3aW5kb3dzLFxyXG5cdFx0cmVzZXJ2ZVBlcmNlbnRhZ2UsXHJcblx0fSA9IGlucHV0O1xyXG5cclxuXHQvLyBDYWxjdWxhdGUgdG90YWwgd2FsbCBhcmVhXHJcblx0Ly8gRm9ybXVsYTogMiDDlyAoTGVuZ3RoICsgV2lkdGgpIMOXIEhlaWdodFxyXG5cdGNvbnN0IHRvdGFsV2FsbEFyZWEgPSAyICogKHJvb21MZW5ndGggKyByb29tV2lkdGgpICogd2FsbEhlaWdodDtcclxuXHJcblx0Ly8gQ2FsY3VsYXRlIGRvb3JzIGFyZWFcclxuXHRjb25zdCBkb29yc0FyZWEgPSBkb29ycy5yZWR1Y2UoKHRvdGFsLCBkb29yKSA9PiB7XHJcblx0XHRyZXR1cm4gdG90YWwgKyBkb29yLndpZHRoICogZG9vci5oZWlnaHQ7XHJcblx0fSwgMCk7XHJcblxyXG5cdC8vIENhbGN1bGF0ZSB3aW5kb3dzIGFyZWFcclxuXHRjb25zdCB3aW5kb3dzQXJlYSA9IHdpbmRvd3MucmVkdWNlKCh0b3RhbCwgd2luZG93KSA9PiB7XHJcblx0XHRyZXR1cm4gdG90YWwgKyB3aW5kb3cud2lkdGggKiB3aW5kb3cuaGVpZ2h0O1xyXG5cdH0sIDApO1xyXG5cclxuXHQvLyBUb3RhbCBvcGVuaW5ncyBhcmVhXHJcblx0Y29uc3Qgb3BlbmluZ3NBcmVhID0gZG9vcnNBcmVhICsgd2luZG93c0FyZWE7XHJcblxyXG5cdC8vIFVzZWZ1bCB3YWxsIGFyZWEgKGFmdGVyIHN1YnRyYWN0aW5nIG9wZW5pbmdzKVxyXG5cdGNvbnN0IHVzZWZ1bFdhbGxBcmVhID0gTWF0aC5tYXgoMCwgdG90YWxXYWxsQXJlYSAtIG9wZW5pbmdzQXJlYSk7XHJcblxyXG5cdC8vIENhbGN1bGF0ZSByb2xsIGFyZWFcclxuXHRjb25zdCByb2xsQXJlYSA9IHJvbGxXaWR0aCAqIHJvbGxMZW5ndGg7XHJcblxyXG5cdC8vIENhbGN1bGF0ZSByZXNlcnZlIGFyZWFcclxuXHRjb25zdCByZXNlcnZlQXJlYSA9IHVzZWZ1bFdhbGxBcmVhICogKHJlc2VydmVQZXJjZW50YWdlIC8gMTAwKTtcclxuXHJcblx0Ly8gVG90YWwgYXJlYSBuZWVkZWQgKHVzZWZ1bCBhcmVhICsgcmVzZXJ2ZSlcclxuXHRjb25zdCB0b3RhbEFyZWFOZWVkZWQgPSB1c2VmdWxXYWxsQXJlYSArIHJlc2VydmVBcmVhO1xyXG5cclxuXHQvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHJvbGxzIG5lZWRlZFxyXG5cdGNvbnN0IHJvbGxzTmVlZGVkID0gTWF0aC5jZWlsKHRvdGFsQXJlYU5lZWRlZCAvIHJvbGxBcmVhKTtcclxuXHJcblx0Ly8gUmVjb21tZW5kZWQgcm9sbHMgKGFkZCAxIGV4dHJhIGZvciBwYXR0ZXJuIG1hdGNoaW5nIGFuZCBmdXR1cmUgcmVwYWlycylcclxuXHRjb25zdCByZWNvbW1lbmRlZFJvbGxzID0gcm9sbHNOZWVkZWQgKyAxO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Ly8gUm9vbSBkaW1lbnNpb25zXHJcblx0XHRyb29tTGVuZ3RoOiBNYXRoLnJvdW5kKHJvb21MZW5ndGggKiAxMDApIC8gMTAwLFxyXG5cdFx0cm9vbVdpZHRoOiBNYXRoLnJvdW5kKHJvb21XaWR0aCAqIDEwMCkgLyAxMDAsXHJcblx0XHR3YWxsSGVpZ2h0OiBNYXRoLnJvdW5kKHdhbGxIZWlnaHQgKiAxMDApIC8gMTAwLFxyXG5cclxuXHRcdC8vIFdhbGwgYXJlYSBjYWxjdWxhdGlvbnNcclxuXHRcdHRvdGFsV2FsbEFyZWE6IE1hdGgucm91bmQodG90YWxXYWxsQXJlYSAqIDEwMCkgLyAxMDAsXHJcblx0XHRkb29yc0FyZWE6IE1hdGgucm91bmQoZG9vcnNBcmVhICogMTAwKSAvIDEwMCxcclxuXHRcdHdpbmRvd3NBcmVhOiBNYXRoLnJvdW5kKHdpbmRvd3NBcmVhICogMTAwKSAvIDEwMCxcclxuXHRcdG9wZW5pbmdzQXJlYTogTWF0aC5yb3VuZChvcGVuaW5nc0FyZWEgKiAxMDApIC8gMTAwLFxyXG5cdFx0dXNlZnVsV2FsbEFyZWE6IE1hdGgucm91bmQodXNlZnVsV2FsbEFyZWEgKiAxMDApIC8gMTAwLFxyXG5cclxuXHRcdC8vIFJvbGwgY2FsY3VsYXRpb25zXHJcblx0XHRyb2xsV2lkdGg6IE1hdGgucm91bmQocm9sbFdpZHRoICogMTAwKSAvIDEwMCxcclxuXHRcdHJvbGxMZW5ndGg6IE1hdGgucm91bmQocm9sbExlbmd0aCAqIDEwMCkgLyAxMDAsXHJcblx0XHRyb2xsQXJlYTogTWF0aC5yb3VuZChyb2xsQXJlYSAqIDEwMCkgLyAxMDAsXHJcblxyXG5cdFx0Ly8gUmVzZXJ2ZSBhbmQgZmluYWwgY2FsY3VsYXRpb25zXHJcblx0XHRyZXNlcnZlUGVyY2VudGFnZTogTWF0aC5yb3VuZChyZXNlcnZlUGVyY2VudGFnZSAqIDEwMCkgLyAxMDAsXHJcblx0XHRyZXNlcnZlQXJlYTogTWF0aC5yb3VuZChyZXNlcnZlQXJlYSAqIDEwMCkgLyAxMDAsXHJcblx0XHR0b3RhbEFyZWFOZWVkZWQ6IE1hdGgucm91bmQodG90YWxBcmVhTmVlZGVkICogMTAwKSAvIDEwMCxcclxuXHRcdHJvbGxzTmVlZGVkOiBNYXRoLnJvdW5kKHJvbGxzTmVlZGVkKSxcclxuXHRcdHJlY29tbWVuZGVkUm9sbHM6IE1hdGgucm91bmQocmVjb21tZW5kZWRSb2xscyksXHJcblxyXG5cdFx0Ly8gQWRkaXRpb25hbCBpbmZvXHJcblx0XHRkb29yc0NvdW50OiBkb29ycy5sZW5ndGgsXHJcblx0XHR3aW5kb3dzQ291bnQ6IHdpbmRvd3MubGVuZ3RoLFxyXG5cdH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVdhbGxwYXBlcklucHV0KFxyXG5cdGlucHV0OiBQYXJ0aWFsPFdhbGxwYXBlcklucHV0PlxyXG4pOiBzdHJpbmdbXSB7XHJcblx0Y29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuXHQvLyBSb29tIGRpbWVuc2lvbnMgdmFsaWRhdGlvblxyXG5cdGlmICghaW5wdXQucm9vbUxlbmd0aCB8fCBpbnB1dC5yb29tTGVuZ3RoIDw9IDApIHtcclxuXHRcdGVycm9ycy5wdXNoKCfQlNC70LjQvdCwINC60L7QvNC90LDRgtGLINC00L7Qu9C20L3QsCDQsdGL0YLRjCDQsdC+0LvRjNGI0LUgMCcpO1xyXG5cdH1cclxuXHJcblx0aWYgKGlucHV0LnJvb21MZW5ndGggJiYgaW5wdXQucm9vbUxlbmd0aCA+IDEwMCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ9CU0LvQuNC90LAg0LrQvtC80L3QsNGC0Ysg0L3QtSDQvNC+0LbQtdGCINCx0YvRgtGMINCx0L7Qu9GM0YjQtSAxMDAg0LzQtdGC0YDQvtCyJyk7XHJcblx0fVxyXG5cclxuXHRpZiAoIWlucHV0LnJvb21XaWR0aCB8fCBpbnB1dC5yb29tV2lkdGggPD0gMCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ9Co0LjRgNC40L3QsCDQutC+0LzQvdCw0YLRiyDQtNC+0LvQttC90LAg0LHRi9GC0Ywg0LHQvtC70YzRiNC1IDAnKTtcclxuXHR9XHJcblxyXG5cdGlmIChpbnB1dC5yb29tV2lkdGggJiYgaW5wdXQucm9vbVdpZHRoID4gMTAwKSB7XHJcblx0XHRlcnJvcnMucHVzaCgn0KjQuNGA0LjQvdCwINC60L7QvNC90LDRgtGLINC90LUg0LzQvtC20LXRgiDQsdGL0YLRjCDQsdC+0LvRjNGI0LUgMTAwINC80LXRgtGA0L7QsicpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFpbnB1dC53YWxsSGVpZ2h0IHx8IGlucHV0LndhbGxIZWlnaHQgPD0gMCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ9CS0YvRgdC+0YLQsCDRgdGC0LXQvSDQtNC+0LvQttC90LAg0LHRi9GC0Ywg0LHQvtC70YzRiNC1IDAnKTtcclxuXHR9XHJcblxyXG5cdGlmIChpbnB1dC53YWxsSGVpZ2h0ICYmIGlucHV0LndhbGxIZWlnaHQgPiAxMCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ9CS0YvRgdC+0YLQsCDRgdGC0LXQvSDQvdC1INC80L7QttC10YIg0LHRi9GC0Ywg0LHQvtC70YzRiNC1IDEwINC80LXRgtGA0L7QsicpO1xyXG5cdH1cclxuXHJcblx0Ly8gUm9sbCBkaW1lbnNpb25zIHZhbGlkYXRpb25cclxuXHRpZiAoIWlucHV0LnJvbGxXaWR0aCB8fCBpbnB1dC5yb2xsV2lkdGggPD0gMCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ9Co0LjRgNC40L3QsCDRgNGD0LvQvtC90LAg0LTQvtC70LbQvdCwINCx0YvRgtGMINCx0L7Qu9GM0YjQtSAwJyk7XHJcblx0fVxyXG5cclxuXHRpZiAoaW5wdXQucm9sbFdpZHRoICYmIGlucHV0LnJvbGxXaWR0aCA+IDUpIHtcclxuXHRcdGVycm9ycy5wdXNoKCfQqNC40YDQuNC90LAg0YDRg9C70L7QvdCwINC90LUg0LzQvtC20LXRgiDQsdGL0YLRjCDQsdC+0LvRjNGI0LUgNSDQvNC10YLRgNC+0LInKTtcclxuXHR9XHJcblxyXG5cdGlmICghaW5wdXQucm9sbExlbmd0aCB8fCBpbnB1dC5yb2xsTGVuZ3RoIDw9IDApIHtcclxuXHRcdGVycm9ycy5wdXNoKCfQlNC70LjQvdCwINGA0YPQu9C+0L3QsCDQtNC+0LvQttC90LAg0LHRi9GC0Ywg0LHQvtC70YzRiNC1IDAnKTtcclxuXHR9XHJcblxyXG5cdGlmIChpbnB1dC5yb2xsTGVuZ3RoICYmIGlucHV0LnJvbGxMZW5ndGggPiA1MCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ9CU0LvQuNC90LAg0YDRg9C70L7QvdCwINC90LUg0LzQvtC20LXRgiDQsdGL0YLRjCDQsdC+0LvRjNGI0LUgNTAg0LzQtdGC0YDQvtCyJyk7XHJcblx0fVxyXG5cclxuXHQvLyBSZXNlcnZlIHBlcmNlbnRhZ2UgdmFsaWRhdGlvblxyXG5cdGlmIChpbnB1dC5yZXNlcnZlUGVyY2VudGFnZSAhPT0gdW5kZWZpbmVkICYmIGlucHV0LnJlc2VydmVQZXJjZW50YWdlIDwgMCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ9CX0LDQv9Cw0YEg0L3QtSDQvNC+0LbQtdGCINCx0YvRgtGMINC+0YLRgNC40YbQsNGC0LXQu9GM0L3Ri9C8Jyk7XHJcblx0fVxyXG5cclxuXHRpZiAoaW5wdXQucmVzZXJ2ZVBlcmNlbnRhZ2UgJiYgaW5wdXQucmVzZXJ2ZVBlcmNlbnRhZ2UgPiAxMDApIHtcclxuXHRcdGVycm9ycy5wdXNoKCfQl9Cw0L/QsNGBINC90LUg0LzQvtC20LXRgiDQsdGL0YLRjCDQsdC+0LvRjNGI0LUgMTAwJScpO1xyXG5cdH1cclxuXHJcblx0Ly8gRG9vcnMgYW5kIHdpbmRvd3MgdmFsaWRhdGlvblxyXG5cdGlmIChpbnB1dC5kb29ycykge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5kb29ycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjb25zdCBkb29yID0gaW5wdXQuZG9vcnNbaV07XHJcblx0XHRcdGlmIChkb29yLndpZHRoIDw9IDAgfHwgZG9vci5oZWlnaHQgPD0gMCkge1xyXG5cdFx0XHRcdGVycm9ycy5wdXNoKGDQlNCy0LXRgNGMICR7aSArIDF9OiDRgNCw0LfQvNC10YDRiyDQtNC+0LvQttC90Ysg0LHRi9GC0Ywg0LHQvtC70YzRiNC1IDBgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoZG9vci53aWR0aCA+IDUgfHwgZG9vci5oZWlnaHQgPiA1KSB7XHJcblx0XHRcdFx0ZXJyb3JzLnB1c2goXHJcblx0XHRcdFx0XHRg0JTQstC10YDRjCAke2kgKyAxfTog0YDQsNC30LzQtdGA0Ysg0L3QtSDQvNC+0LPRg9GCINCx0YvRgtGMINCx0L7Qu9GM0YjQtSA1INC80LXRgtGA0L7QsmBcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoaW5wdXQud2luZG93cykge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC53aW5kb3dzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IHdpbmRvdyA9IGlucHV0LndpbmRvd3NbaV07XHJcblx0XHRcdGlmICh3aW5kb3cud2lkdGggPD0gMCB8fCB3aW5kb3cuaGVpZ2h0IDw9IDApIHtcclxuXHRcdFx0XHRlcnJvcnMucHVzaChg0J7QutC90L4gJHtpICsgMX06INGA0LDQt9C80LXRgNGLINC00L7Qu9C20L3RiyDQsdGL0YLRjCDQsdC+0LvRjNGI0LUgMGApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh3aW5kb3cud2lkdGggPiAxMCB8fCB3aW5kb3cuaGVpZ2h0ID4gMTApIHtcclxuXHRcdFx0XHRlcnJvcnMucHVzaChcclxuXHRcdFx0XHRcdGDQntC60L3QviAke2kgKyAxfTog0YDQsNC30LzQtdGA0Ysg0L3QtSDQvNC+0LPRg9GCINCx0YvRgtGMINCx0L7Qu9GM0YjQtSAxMCDQvNC10YLRgNC+0LJgXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGVycm9ycztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdhbGxwYXBlckFyZWEoYXJlYTogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRyZXR1cm4gKFxyXG5cdFx0bmV3IEludGwuTnVtYmVyRm9ybWF0KCdydS1SVScsIHtcclxuXHRcdFx0bWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxyXG5cdFx0XHRtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIsXHJcblx0XHR9KS5mb3JtYXQoYXJlYSkgKyAnINC8wrInXHJcblx0KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdhbGxwYXBlck51bWJlcih2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRyZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KCdydS1SVScsIHtcclxuXHRcdG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMCxcclxuXHRcdG1heGltdW1GcmFjdGlvbkRpZ2l0czogMixcclxuXHR9KS5mb3JtYXQodmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhbmRhcmRSb2xsU2l6ZXMoKTogQXJyYXk8e1xyXG5cdHdpZHRoOiBudW1iZXI7XHJcblx0bGVuZ3RoOiBudW1iZXI7XHJcblx0bGFiZWw6IHN0cmluZztcclxuXHRkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG59PiB7XHJcblx0cmV0dXJuIFtcclxuXHRcdHtcclxuXHRcdFx0d2lkdGg6IDAuNTMsXHJcblx0XHRcdGxlbmd0aDogMTAuMDUsXHJcblx0XHRcdGxhYmVsOiAnMC41MyDDlyAxMC4wNSDQvCcsXHJcblx0XHRcdGRlc2NyaXB0aW9uOiAn0KHRgtCw0L3QtNCw0YDRgtC90YvQuSDRgNCw0LfQvNC10YAgKNC10LLRgNC+0L/QtdC50YHQutC40LkpJyxcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHdpZHRoOiAwLjcsXHJcblx0XHRcdGxlbmd0aDogMTAuMDUsXHJcblx0XHRcdGxhYmVsOiAnMC43IMOXIDEwLjA1INC8JyxcclxuXHRcdFx0ZGVzY3JpcHRpb246ICfQqNC40YDQvtC60LjQuSDRgNGD0LvQvtC9JyxcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdHdpZHRoOiAxLjA2LFxyXG5cdFx0XHRsZW5ndGg6IDEwLjA1LFxyXG5cdFx0XHRsYWJlbDogJzEuMDYgw5cgMTAuMDUg0LwnLFxyXG5cdFx0XHRkZXNjcmlwdGlvbjogJ9Ce0YfQtdC90Ywg0YjQuNGA0L7QutC40Lkg0YDRg9C70L7QvScsXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHR3aWR0aDogMC41MyxcclxuXHRcdFx0bGVuZ3RoOiAxNS4wLFxyXG5cdFx0XHRsYWJlbDogJzAuNTMgw5cgMTUuMCDQvCcsXHJcblx0XHRcdGRlc2NyaXB0aW9uOiAn0JTQu9C40L3QvdGL0Lkg0YDRg9C70L7QvScsXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHR3aWR0aDogMC43LFxyXG5cdFx0XHRsZW5ndGg6IDE1LjAsXHJcblx0XHRcdGxhYmVsOiAnMC43IMOXIDE1LjAg0LwnLFxyXG5cdFx0XHRkZXNjcmlwdGlvbjogJ9Co0LjRgNC+0LrQuNC5INC00LvQuNC90L3Ri9C5INGA0YPQu9C+0L0nLFxyXG5cdFx0fSxcclxuXHRdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhbmRhcmRSZXNlcnZlUGVyY2VudGFnZXMoKTogQXJyYXk8e1xyXG5cdHZhbHVlOiBudW1iZXI7XHJcblx0bGFiZWw6IHN0cmluZztcclxuXHRkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG59PiB7XHJcblx0cmV0dXJuIFtcclxuXHRcdHsgdmFsdWU6IDUsIGxhYmVsOiAnNSUnLCBkZXNjcmlwdGlvbjogJ9Cc0LjQvdC40LzQsNC70YzQvdGL0Lkg0LfQsNC/0LDRgScgfSxcclxuXHRcdHsgdmFsdWU6IDEwLCBsYWJlbDogJzEwJScsIGRlc2NyaXB0aW9uOiAn0KHRgtCw0L3QtNCw0YDRgtC90YvQuSDQt9Cw0L/QsNGBJyB9LFxyXG5cdFx0eyB2YWx1ZTogMTUsIGxhYmVsOiAnMTUlJywgZGVzY3JpcHRpb246ICfQo9Cy0LXQu9C40YfQtdC90L3Ri9C5INC30LDQv9Cw0YEnIH0sXHJcblx0XHR7IHZhbHVlOiAyMCwgbGFiZWw6ICcyMCUnLCBkZXNjcmlwdGlvbjogJ9CR0L7Qu9GM0YjQvtC5INC30LDQv9Cw0YEnIH0sXHJcblx0XTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZERvb3IoaW5wdXQ6IFdhbGxwYXBlcklucHV0KTogV2FsbHBhcGVySW5wdXQge1xyXG5cdHJldHVybiB7XHJcblx0XHQuLi5pbnB1dCxcclxuXHRcdGRvb3JzOiBbLi4uaW5wdXQuZG9vcnMsIHsgd2lkdGg6IDAuOCwgaGVpZ2h0OiAyLjEgfV0sIC8vIFN0YW5kYXJkIGRvb3Igc2l6ZVxyXG5cdH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRXaW5kb3coaW5wdXQ6IFdhbGxwYXBlcklucHV0KTogV2FsbHBhcGVySW5wdXQge1xyXG5cdHJldHVybiB7XHJcblx0XHQuLi5pbnB1dCxcclxuXHRcdHdpbmRvd3M6IFsuLi5pbnB1dC53aW5kb3dzLCB7IHdpZHRoOiAxLjIsIGhlaWdodDogMS41IH1dLCAvLyBTdGFuZGFyZCB3aW5kb3cgc2l6ZVxyXG5cdH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb29yKFxyXG5cdGlucHV0OiBXYWxscGFwZXJJbnB1dCxcclxuXHRpbmRleDogbnVtYmVyXHJcbik6IFdhbGxwYXBlcklucHV0IHtcclxuXHRjb25zdCBuZXdEb29ycyA9IGlucHV0LmRvb3JzLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpO1xyXG5cdHJldHVybiB7XHJcblx0XHQuLi5pbnB1dCxcclxuXHRcdGRvb3JzOiBuZXdEb29ycyxcclxuXHR9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlV2luZG93KFxyXG5cdGlucHV0OiBXYWxscGFwZXJJbnB1dCxcclxuXHRpbmRleDogbnVtYmVyXHJcbik6IFdhbGxwYXBlcklucHV0IHtcclxuXHRjb25zdCBuZXdXaW5kb3dzID0gaW5wdXQud2luZG93cy5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KTtcclxuXHRyZXR1cm4ge1xyXG5cdFx0Li4uaW5wdXQsXHJcblx0XHR3aW5kb3dzOiBuZXdXaW5kb3dzLFxyXG5cdH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEb29yKFxyXG5cdGlucHV0OiBXYWxscGFwZXJJbnB1dCxcclxuXHRpbmRleDogbnVtYmVyLFxyXG5cdGRvb3I6IERvb3JXaW5kb3dcclxuKTogV2FsbHBhcGVySW5wdXQge1xyXG5cdGNvbnN0IG5ld0Rvb3JzID0gWy4uLmlucHV0LmRvb3JzXTtcclxuXHRuZXdEb29yc1tpbmRleF0gPSBkb29yO1xyXG5cdHJldHVybiB7XHJcblx0XHQuLi5pbnB1dCxcclxuXHRcdGRvb3JzOiBuZXdEb29ycyxcclxuXHR9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlV2luZG93KFxyXG5cdGlucHV0OiBXYWxscGFwZXJJbnB1dCxcclxuXHRpbmRleDogbnVtYmVyLFxyXG5cdHdpbmRvdzogRG9vcldpbmRvd1xyXG4pOiBXYWxscGFwZXJJbnB1dCB7XHJcblx0Y29uc3QgbmV3V2luZG93cyA9IFsuLi5pbnB1dC53aW5kb3dzXTtcclxuXHRuZXdXaW5kb3dzW2luZGV4XSA9IHdpbmRvdztcclxuXHRyZXR1cm4ge1xyXG5cdFx0Li4uaW5wdXQsXHJcblx0XHR3aW5kb3dzOiBuZXdXaW5kb3dzLFxyXG5cdH07XHJcbn1cclxuIl0sIm5hbWVzIjpbImNhbGN1bGF0ZVdhbGxwYXBlciIsImlucHV0Iiwicm9vbUxlbmd0aCIsInJvb21XaWR0aCIsIndhbGxIZWlnaHQiLCJyb2xsV2lkdGgiLCJyb2xsTGVuZ3RoIiwiZG9vcnMiLCJ3aW5kb3dzIiwicmVzZXJ2ZVBlcmNlbnRhZ2UiLCJ0b3RhbFdhbGxBcmVhIiwiZG9vcnNBcmVhIiwicmVkdWNlIiwidG90YWwiLCJkb29yIiwid2lkdGgiLCJoZWlnaHQiLCJ3aW5kb3dzQXJlYSIsIndpbmRvdyIsIm9wZW5pbmdzQXJlYSIsInVzZWZ1bFdhbGxBcmVhIiwiTWF0aCIsIm1heCIsInJvbGxBcmVhIiwicmVzZXJ2ZUFyZWEiLCJ0b3RhbEFyZWFOZWVkZWQiLCJyb2xsc05lZWRlZCIsImNlaWwiLCJyZWNvbW1lbmRlZFJvbGxzIiwicm91bmQiLCJkb29yc0NvdW50IiwibGVuZ3RoIiwid2luZG93c0NvdW50IiwidmFsaWRhdGVXYWxscGFwZXJJbnB1dCIsImVycm9ycyIsInB1c2giLCJ1bmRlZmluZWQiLCJpIiwiZm9ybWF0V2FsbHBhcGVyQXJlYSIsImFyZWEiLCJJbnRsIiwiTnVtYmVyRm9ybWF0IiwibWluaW11bUZyYWN0aW9uRGlnaXRzIiwibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwiZm9ybWF0IiwiZm9ybWF0V2FsbHBhcGVyTnVtYmVyIiwidmFsdWUiLCJnZXRTdGFuZGFyZFJvbGxTaXplcyIsImxhYmVsIiwiZGVzY3JpcHRpb24iLCJnZXRTdGFuZGFyZFJlc2VydmVQZXJjZW50YWdlcyIsImFkZERvb3IiLCJhZGRXaW5kb3ciLCJyZW1vdmVEb29yIiwiaW5kZXgiLCJuZXdEb29ycyIsImZpbHRlciIsIl8iLCJyZW1vdmVXaW5kb3ciLCJuZXdXaW5kb3dzIiwidXBkYXRlRG9vciIsInVwZGF0ZVdpbmRvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/calculators/wallpaper.ts\n"));

/***/ })

});