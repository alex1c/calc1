"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[locale]/calc/credit-loan/page",{

/***/ "(app-pages-browser)/./src/lib/calculators/loan.ts":
/*!*************************************!*\
  !*** ./src/lib/calculators/loan.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateAnnuityLoan: function() { return /* binding */ calculateAnnuityLoan; },\n/* harmony export */   calculateDifferentiatedLoan: function() { return /* binding */ calculateDifferentiatedLoan; },\n/* harmony export */   calculateLoan: function() { return /* binding */ calculateLoan; },\n/* harmony export */   exportPaymentScheduleToCSV: function() { return /* binding */ exportPaymentScheduleToCSV; },\n/* harmony export */   generatePaymentSchedule: function() { return /* binding */ generatePaymentSchedule; },\n/* harmony export */   validateLoanInput: function() { return /* binding */ validateLoanInput; }\n/* harmony export */ });\n/**\r\n * Loan calculation library for credit calculators\r\n * Supports both annuity and differentiated payment methods\r\n */ /**\r\n * Calculate annuity loan payments (fixed monthly payment)\r\n */ function calculateAnnuityLoan(input) {\n    const { loanAmount, termMonths, interestRate, additionalPayment = 0 } = input;\n    const monthlyRate = interestRate / 100 / 12;\n    const effectiveLoanAmount = loanAmount - (input.downPayment || 0);\n    // Calculate base monthly payment\n    const baseMonthlyPayment = monthlyRate === 0 ? effectiveLoanAmount / termMonths : effectiveLoanAmount * monthlyRate * Math.pow(1 + monthlyRate, termMonths) / (Math.pow(1 + monthlyRate, termMonths) - 1);\n    const totalMonthlyPayment = baseMonthlyPayment + additionalPayment;\n    // Calculate payment schedule\n    const schedule = [];\n    let balance = effectiveLoanAmount;\n    let totalPayments = 0;\n    let totalInterest = 0;\n    let effectiveTerm = 0;\n    for(let month = 1; month <= termMonths; month++){\n        const interestPayment = balance * monthlyRate;\n        const principalPayment = Math.min(totalMonthlyPayment - interestPayment, balance);\n        const actualPayment = principalPayment + interestPayment;\n        balance -= principalPayment;\n        totalPayments += actualPayment;\n        totalInterest += interestPayment;\n        effectiveTerm = month;\n        schedule.push({\n            month,\n            payment: actualPayment,\n            interest: interestPayment,\n            principal: principalPayment,\n            balance: Math.max(0, balance)\n        });\n        // If balance is paid off early due to additional payments\n        if (balance <= 0.01) {\n            break;\n        }\n    }\n    return {\n        monthlyPayment: totalMonthlyPayment,\n        totalPayments,\n        totalInterest,\n        effectiveTerm,\n        paymentSchedule: schedule\n    };\n}\n/**\r\n * Calculate differentiated loan payments (decreasing monthly payment)\r\n */ function calculateDifferentiatedLoan(input) {\n    var _schedule_;\n    const { loanAmount, termMonths, interestRate, additionalPayment = 0 } = input;\n    const monthlyRate = interestRate / 100 / 12;\n    const effectiveLoanAmount = loanAmount - (input.downPayment || 0);\n    const basePrincipalPayment = effectiveLoanAmount / termMonths;\n    // Calculate payment schedule\n    const schedule = [];\n    let balance = effectiveLoanAmount;\n    let totalPayments = 0;\n    let totalInterest = 0;\n    let effectiveTerm = 0;\n    for(let month = 1; month <= termMonths; month++){\n        const interestPayment = balance * monthlyRate;\n        const principalPayment = Math.min(basePrincipalPayment, balance);\n        const additionalPrincipal = Math.min(additionalPayment, balance - principalPayment);\n        const totalPrincipalPayment = principalPayment + additionalPrincipal;\n        const totalPayment = totalPrincipalPayment + interestPayment;\n        balance -= totalPrincipalPayment;\n        totalPayments += totalPayment;\n        totalInterest += interestPayment;\n        effectiveTerm = month;\n        schedule.push({\n            month,\n            payment: totalPayment,\n            interest: interestPayment,\n            principal: totalPrincipalPayment,\n            balance: Math.max(0, balance)\n        });\n        // If balance is paid off early due to additional payments\n        if (balance <= 0.01) {\n            break;\n        }\n    }\n    // First payment is the highest for differentiated loans\n    const firstPayment = ((_schedule_ = schedule[0]) === null || _schedule_ === void 0 ? void 0 : _schedule_.payment) || 0;\n    return {\n        monthlyPayment: firstPayment,\n        totalPayments,\n        totalInterest,\n        effectiveTerm,\n        paymentSchedule: schedule\n    };\n}\n/**\r\n * Generate payment schedule for both loan types\r\n */ function generatePaymentSchedule(input) {\n    if (input.paymentType === \"annuity\") {\n        return calculateAnnuityLoan(input).paymentSchedule;\n    } else {\n        return calculateDifferentiatedLoan(input).paymentSchedule;\n    }\n}\n/**\r\n * Calculate loan with specified payment type\r\n */ function calculateLoan(input) {\n    if (input.paymentType === \"annuity\") {\n        return calculateAnnuityLoan(input);\n    } else {\n        return calculateDifferentiatedLoan(input);\n    }\n}\n/**\r\n * Export payment schedule as CSV\r\n */ function exportPaymentScheduleToCSV(schedule) {\n    const headers = [\n        \"Month\",\n        \"Payment\",\n        \"Interest\",\n        \"Principal\",\n        \"Balance\"\n    ];\n    const rows = schedule.map((item)=>[\n            item.month,\n            item.payment.toFixed(2),\n            item.interest.toFixed(2),\n            item.principal.toFixed(2),\n            item.balance.toFixed(2)\n        ]);\n    return [\n        headers,\n        ...rows\n    ].map((row)=>row.join(\",\")).join(\"\\n\");\n}\n/**\r\n * Validate loan input parameters\r\n */ function validateLoanInput(input) {\n    const errors = [];\n    if (!input.loanAmount || input.loanAmount <= 0) {\n        errors.push(\"Loan amount must be greater than 0\");\n    }\n    // Calculate total term in months from years and months\n    const totalTermMonths = (input.termYears || 0) * 12 + (input.termMonths || 0);\n    if (totalTermMonths < 1 || totalTermMonths > 360) {\n        errors.push(\"Loan term must be between 1 month and 30 years\");\n    }\n    if (input.interestRate === undefined || input.interestRate < 0 || input.interestRate > 100) {\n        errors.push(\"Interest rate must be between 0% and 100%\");\n    }\n    if (input.downPayment && input.downPayment < 0) {\n        errors.push(\"Down payment cannot be negative\");\n    }\n    if (input.downPayment && input.downPayment >= input.loanAmount) {\n        errors.push(\"Down payment cannot be greater than or equal to loan amount\");\n    }\n    if (input.additionalPayment && input.additionalPayment < 0) {\n        errors.push(\"Additional payment cannot be negative\");\n    }\n    return errors;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY2FsY3VsYXRvcnMvbG9hbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0E0QkQ7O0NBRUMsR0FDTSxTQUFTQSxxQkFBcUJDLEtBQWdCO0lBQ3BELE1BQU0sRUFDTEMsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLFlBQVksRUFDWkMsb0JBQW9CLENBQUMsRUFDckIsR0FBR0o7SUFDSixNQUFNSyxjQUFjRixlQUFlLE1BQU07SUFDekMsTUFBTUcsc0JBQXNCTCxhQUFjRCxDQUFBQSxNQUFNTyxXQUFXLElBQUk7SUFFL0QsaUNBQWlDO0lBQ2pDLE1BQU1DLHFCQUNMSCxnQkFBZ0IsSUFDYkMsc0JBQXNCSixhQUN0QixzQkFDQUcsY0FDQUksS0FBS0MsR0FBRyxDQUFDLElBQUlMLGFBQWFILGNBQ3pCTyxDQUFBQSxLQUFLQyxHQUFHLENBQUMsSUFBSUwsYUFBYUgsY0FBYztJQUU3QyxNQUFNUyxzQkFBc0JILHFCQUFxQko7SUFFakQsNkJBQTZCO0lBQzdCLE1BQU1RLFdBQWtDLEVBQUU7SUFDMUMsSUFBSUMsVUFBVVA7SUFDZCxJQUFJUSxnQkFBZ0I7SUFDcEIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUlDLGdCQUFnQjtJQUVwQixJQUFLLElBQUlDLFFBQVEsR0FBR0EsU0FBU2YsWUFBWWUsUUFBUztRQUNqRCxNQUFNQyxrQkFBa0JMLFVBQVVSO1FBQ2xDLE1BQU1jLG1CQUFtQlYsS0FBS1csR0FBRyxDQUNoQ1Qsc0JBQXNCTyxpQkFDdEJMO1FBRUQsTUFBTVEsZ0JBQWdCRixtQkFBbUJEO1FBRXpDTCxXQUFXTTtRQUNYTCxpQkFBaUJPO1FBQ2pCTixpQkFBaUJHO1FBQ2pCRixnQkFBZ0JDO1FBRWhCTCxTQUFTVSxJQUFJLENBQUM7WUFDYkw7WUFDQU0sU0FBU0Y7WUFDVEcsVUFBVU47WUFDVk8sV0FBV047WUFDWE4sU0FBU0osS0FBS2lCLEdBQUcsQ0FBQyxHQUFHYjtRQUN0QjtRQUVBLDBEQUEw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QUFJLENBQUMvQyxNQUFNQyxVQUFVLElBQUlELE1BQU1DLFVBQVUsSUFBSSxHQUFHO1FBQy9DOEMsT0FBT3pCLElBQUksQ0FBQztJQUNiO0lBRUEsdURBQXVEO0lBQ3ZELE1BQU0wQixrQkFBa0IsQ0FBQ2hELE1BQU1pRCxTQUFTLElBQUksS0FBSyxLQUFNakQsQ0FBQUEsTUFBTUUsVUFBVSxJQUFJO0lBRTNFLElBQUk4QyxrQkFBa0IsS0FBS0Esa0JBQWtCLEtBQUs7UUFDakRELE9BQU96QixJQUFJLENBQUM7SUFDYjtJQUVBLElBQ0N0QixNQUFNRyxZQUFZLEtBQUsrQyxhQUN2QmxELE1BQU1HLFlBQVksR0FBRyxLQUNyQkgsTUFBTUcsWUFBWSxHQUFHLEtBQ3BCO1FBQ0Q0QyxPQUFPekIsSUFBSSxDQUFDO0lBQ2I7SUFFQSxJQUFJdEIsTUFBTU8sV0FBVyxJQUFJUCxNQUFNTyxXQUFXLEdBQUcsR0FBRztRQUMvQ3dDLE9BQU96QixJQUFJLENBQUM7SUFDYjtJQUVBLElBQUl0QixNQUFNTyxXQUFXLElBQUlQLE1BQU1PLFdBQVcsSUFBSVAsTUFBTUMsVUFBVSxFQUFFO1FBQy9EOEMsT0FBT3pCLElBQUksQ0FDVjtJQUVGO0lBRUEsSUFBSXRCLE1BQU1JLGlCQUFpQixJQUFJSixNQUFNSSxpQkFBaUIsR0FBRyxHQUFHO1FBQzNEMkMsT0FBT3pCLElBQUksQ0FBQztJQUNiO0lBRUEsT0FBT3lCO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9jYWxjdWxhdG9ycy9sb2FuLnRzPzA5MmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIExvYW4gY2FsY3VsYXRpb24gbGlicmFyeSBmb3IgY3JlZGl0IGNhbGN1bGF0b3JzXHJcbiAqIFN1cHBvcnRzIGJvdGggYW5udWl0eSBhbmQgZGlmZmVyZW50aWF0ZWQgcGF5bWVudCBtZXRob2RzXHJcbiAqL1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMb2FuSW5wdXQge1xyXG5cdGxvYW5BbW91bnQ6IG51bWJlcjtcclxuXHR0ZXJtWWVhcnM6IG51bWJlcjtcclxuXHR0ZXJtTW9udGhzOiBudW1iZXI7XHJcblx0aW50ZXJlc3RSYXRlOiBudW1iZXI7XHJcblx0ZG93blBheW1lbnQ/OiBudW1iZXI7XHJcblx0YWRkaXRpb25hbFBheW1lbnQ/OiBudW1iZXI7XHJcblx0cGF5bWVudFR5cGU6ICdhbm51aXR5JyB8ICdkaWZmZXJlbnRpYXRlZCc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGF5bWVudFNjaGVkdWxlSXRlbSB7XHJcblx0bW9udGg6IG51bWJlcjtcclxuXHRwYXltZW50OiBudW1iZXI7XHJcblx0aW50ZXJlc3Q6IG51bWJlcjtcclxuXHRwcmluY2lwYWw6IG51bWJlcjtcclxuXHRiYWxhbmNlOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTG9hblJlc3VsdCB7XHJcblx0bW9udGhseVBheW1lbnQ6IG51bWJlcjtcclxuXHR0b3RhbFBheW1lbnRzOiBudW1iZXI7XHJcblx0dG90YWxJbnRlcmVzdDogbnVtYmVyO1xyXG5cdGVmZmVjdGl2ZVRlcm06IG51bWJlcjtcclxuXHRwYXltZW50U2NoZWR1bGU6IFBheW1lbnRTY2hlZHVsZUl0ZW1bXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBhbm51aXR5IGxvYW4gcGF5bWVudHMgKGZpeGVkIG1vbnRobHkgcGF5bWVudClcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVBbm51aXR5TG9hbihpbnB1dDogTG9hbklucHV0KTogTG9hblJlc3VsdCB7XHJcblx0Y29uc3Qge1xyXG5cdFx0bG9hbkFtb3VudCxcclxuXHRcdHRlcm1Nb250aHMsXHJcblx0XHRpbnRlcmVzdFJhdGUsXHJcblx0XHRhZGRpdGlvbmFsUGF5bWVudCA9IDAsXHJcblx0fSA9IGlucHV0O1xyXG5cdGNvbnN0IG1vbnRobHlSYXRlID0gaW50ZXJlc3RSYXRlIC8gMTAwIC8gMTI7XHJcblx0Y29uc3QgZWZmZWN0aXZlTG9hbkFtb3VudCA9IGxvYW5BbW91bnQgLSAoaW5wdXQuZG93blBheW1lbnQgfHwgMCk7XHJcblxyXG5cdC8vIENhbGN1bGF0ZSBiYXNlIG1vbnRobHkgcGF5bWVudFxyXG5cdGNvbnN0IGJhc2VNb250aGx5UGF5bWVudCA9XHJcblx0XHRtb250aGx5UmF0ZSA9PT0gMFxyXG5cdFx0XHQ/IGVmZmVjdGl2ZUxvYW5BbW91bnQgLyB0ZXJtTW9udGhzXHJcblx0XHRcdDogKGVmZmVjdGl2ZUxvYW5BbW91bnQgKlxyXG5cdFx0XHRcdFx0bW9udGhseVJhdGUgKlxyXG5cdFx0XHRcdFx0TWF0aC5wb3coMSArIG1vbnRobHlSYXRlLCB0ZXJtTW9udGhzKSkgL1xyXG5cdFx0XHQgIChNYXRoLnBvdygxICsgbW9udGhseVJhdGUsIHRlcm1Nb250aHMpIC0gMSk7XHJcblxyXG5cdGNvbnN0IHRvdGFsTW9udGhseVBheW1lbnQgPSBiYXNlTW9udGhseVBheW1lbnQgKyBhZGRpdGlvbmFsUGF5bWVudDtcclxuXHJcblx0Ly8gQ2FsY3VsYXRlIHBheW1lbnQgc2NoZWR1bGVcclxuXHRjb25zdCBzY2hlZHVsZTogUGF5bWVudFNjaGVkdWxlSXRlbVtdID0gW107XHJcblx0bGV0IGJhbGFuY2UgPSBlZmZlY3RpdmVMb2FuQW1vdW50O1xyXG5cdGxldCB0b3RhbFBheW1lbnRzID0gMDtcclxuXHRsZXQgdG90YWxJbnRlcmVzdCA9IDA7XHJcblx0bGV0IGVmZmVjdGl2ZVRlcm0gPSAwO1xyXG5cclxuXHRmb3IgKGxldCBtb250aCA9IDE7IG1vbnRoIDw9IHRlcm1Nb250aHM7IG1vbnRoKyspIHtcclxuXHRcdGNvbnN0IGludGVyZXN0UGF5bWVudCA9IGJhbGFuY2UgKiBtb250aGx5UmF0ZTtcclxuXHRcdGNvbnN0IHByaW5jaXBhbFBheW1lbnQgPSBNYXRoLm1pbihcclxuXHRcdFx0dG90YWxNb250aGx5UGF5bWVudCAtIGludGVyZXN0UGF5bWVudCxcclxuXHRcdFx0YmFsYW5jZVxyXG5cdFx0KTtcclxuXHRcdGNvbnN0IGFjdHVhbFBheW1lbnQgPSBwcmluY2lwYWxQYXltZW50ICsgaW50ZXJlc3RQYXltZW50O1xyXG5cclxuXHRcdGJhbGFuY2UgLT0gcHJpbmNpcGFsUGF5bWVudDtcclxuXHRcdHRvdGFsUGF5bWVudHMgKz0gYWN0dWFsUGF5bWVudDtcclxuXHRcdHRvdGFsSW50ZXJlc3QgKz0gaW50ZXJlc3RQYXltZW50O1xyXG5cdFx0ZWZmZWN0aXZlVGVybSA9IG1vbnRoO1xyXG5cclxuXHRcdHNjaGVkdWxlLnB1c2goe1xyXG5cdFx0XHRtb250aCxcclxuXHRcdFx0cGF5bWVudDogYWN0dWFsUGF5bWVudCxcclxuXHRcdFx0aW50ZXJlc3Q6IGludGVyZXN0UGF5bWVudCxcclxuXHRcdFx0cHJpbmNpcGFsOiBwcmluY2lwYWxQYXltZW50LFxyXG5cdFx0XHRiYWxhbmNlOiBNYXRoLm1heCgwLCBiYWxhbmNlKSxcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIElmIGJhbGFuY2UgaXMgcGFpZCBvZmYgZWFybHkgZHVlIHRvIGFkZGl0aW9uYWwgcGF5bWVudHNcclxuXHRcdGlmIChiYWxhbmNlIDw9IDAuMDEpIHtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0bW9udGhseVBheW1lbnQ6IHRvdGFsTW9udGhseVBheW1lbnQsXHJcblx0XHR0b3RhbFBheW1lbnRzLFxyXG5cdFx0dG90YWxJbnRlcmVzdCxcclxuXHRcdGVmZmVjdGl2ZVRlcm0sXHJcblx0XHRwYXltZW50U2NoZWR1bGU6IHNjaGVkdWxlLFxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgZGlmZmVyZW50aWF0ZWQgbG9hbiBwYXltZW50cyAoZGVjcmVhc2luZyBtb250aGx5IHBheW1lbnQpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGlmZmVyZW50aWF0ZWRMb2FuKGlucHV0OiBMb2FuSW5wdXQpOiBMb2FuUmVzdWx0IHtcclxuXHRjb25zdCB7XHJcblx0XHRsb2FuQW1vdW50LFxyXG5cdFx0dGVybU1vbnRocyxcclxuXHRcdGludGVyZXN0UmF0ZSxcclxuXHRcdGFkZGl0aW9uYWxQYXltZW50ID0gMCxcclxuXHR9ID0gaW5wdXQ7XHJcblx0Y29uc3QgbW9udGhseVJhdGUgPSBpbnRlcmVzdFJhdGUgLyAxMDAgLyAxMjtcclxuXHRjb25zdCBlZmZlY3RpdmVMb2FuQW1vdW50ID0gbG9hbkFtb3VudCAtIChpbnB1dC5kb3duUGF5bWVudCB8fCAwKTtcclxuXHRjb25zdCBiYXNlUHJpbmNpcGFsUGF5bWVudCA9IGVmZmVjdGl2ZUxvYW5BbW91bnQgLyB0ZXJtTW9udGhzO1xyXG5cclxuXHQvLyBDYWxjdWxhdGUgcGF5bWVudCBzY2hlZHVsZVxyXG5cdGNvbnN0IHNjaGVkdWxlOiBQYXltZW50U2NoZWR1bGVJdGVtW10gPSBbXTtcclxuXHRsZXQgYmFsYW5jZSA9IGVmZmVjdGl2ZUxvYW5BbW91bnQ7XHJcblx0bGV0IHRvdGFsUGF5bWVudHMgPSAwO1xyXG5cdGxldCB0b3RhbEludGVyZXN0ID0gMDtcclxuXHRsZXQgZWZmZWN0aXZlVGVybSA9IDA7XHJcblxyXG5cdGZvciAobGV0IG1vbnRoID0gMTsgbW9udGggPD0gdGVybU1vbnRoczsgbW9udGgrKykge1xyXG5cdFx0Y29uc3QgaW50ZXJlc3RQYXltZW50ID0gYmFsYW5jZSAqIG1vbnRobHlSYXRlO1xyXG5cdFx0Y29uc3QgcHJpbmNpcGFsUGF5bWVudCA9IE1hdGgubWluKGJhc2VQcmluY2lwYWxQYXltZW50LCBiYWxhbmNlKTtcclxuXHRcdGNvbnN0IGFkZGl0aW9uYWxQcmluY2lwYWwgPSBNYXRoLm1pbihcclxuXHRcdFx0YWRkaXRpb25hbFBheW1lbnQsXHJcblx0XHRcdGJhbGFuY2UgLSBwcmluY2lwYWxQYXltZW50XHJcblx0XHQpO1xyXG5cdFx0Y29uc3QgdG90YWxQcmluY2lwYWxQYXltZW50ID0gcHJpbmNpcGFsUGF5bWVudCArIGFkZGl0aW9uYWxQcmluY2lwYWw7XHJcblx0XHRjb25zdCB0b3RhbFBheW1lbnQgPSB0b3RhbFByaW5jaXBhbFBheW1lbnQgKyBpbnRlcmVzdFBheW1lbnQ7XHJcblxyXG5cdFx0YmFsYW5jZSAtPSB0b3RhbFByaW5jaXBhbFBheW1lbnQ7XHJcblx0XHR0b3RhbFBheW1lbnRzICs9IHRvdGFsUGF5bWVudDtcclxuXHRcdHRvdGFsSW50ZXJlc3QgKz0gaW50ZXJlc3RQYXltZW50O1xyXG5cdFx0ZWZmZWN0aXZlVGVybSA9IG1vbnRoO1xyXG5cclxuXHRcdHNjaGVkdWxlLnB1c2goe1xyXG5cdFx0XHRtb250aCxcclxuXHRcdFx0cGF5bWVudDogdG90YWxQYXltZW50LFxyXG5cdFx0XHRpbnRlcmVzdDogaW50ZXJlc3RQYXltZW50LFxyXG5cdFx0XHRwcmluY2lwYWw6IHRvdGFsUHJpbmNpcGFsUGF5bWVudCxcclxuXHRcdFx0YmFsYW5jZTogTWF0aC5tYXgoMCwgYmFsYW5jZSksXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBJZiBiYWxhbmNlIGlzIHBhaWQgb2ZmIGVhcmx5IGR1ZSB0byBhZGRpdGlvbmFsIHBheW1lbnRzXHJcblx0XHRpZiAoYmFsYW5jZSA8PSAwLjAxKSB7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gRmlyc3QgcGF5bWVudCBpcyB0aGUgaGlnaGVzdCBmb3IgZGlmZmVyZW50aWF0ZWQgbG9hbnNcclxuXHRjb25zdCBmaXJzdFBheW1lbnQgPSBzY2hlZHVsZVswXT8ucGF5bWVudCB8fCAwO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0bW9udGhseVBheW1lbnQ6IGZpcnN0UGF5bWVudCxcclxuXHRcdHRvdGFsUGF5bWVudHMsXHJcblx0XHR0b3RhbEludGVyZXN0LFxyXG5cdFx0ZWZmZWN0aXZlVGVybSxcclxuXHRcdHBheW1lbnRTY2hlZHVsZTogc2NoZWR1bGUsXHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHBheW1lbnQgc2NoZWR1bGUgZm9yIGJvdGggbG9hbiB0eXBlc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUGF5bWVudFNjaGVkdWxlKFxyXG5cdGlucHV0OiBMb2FuSW5wdXRcclxuKTogUGF5bWVudFNjaGVkdWxlSXRlbVtdIHtcclxuXHRpZiAoaW5wdXQucGF5bWVudFR5cGUgPT09ICdhbm51aXR5Jykge1xyXG5cdFx0cmV0dXJuIGNhbGN1bGF0ZUFubnVpdHlMb2FuKGlucHV0KS5wYXltZW50U2NoZWR1bGU7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBjYWxjdWxhdGVEaWZmZXJlbnRpYXRlZExvYW4oaW5wdXQpLnBheW1lbnRTY2hlZHVsZTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgbG9hbiB3aXRoIHNwZWNpZmllZCBwYXltZW50IHR5cGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVMb2FuKGlucHV0OiBMb2FuSW5wdXQpOiBMb2FuUmVzdWx0IHtcclxuXHRpZiAoaW5wdXQucGF5bWVudFR5cGUgPT09ICdhbm51aXR5Jykge1xyXG5cdFx0cmV0dXJuIGNhbGN1bGF0ZUFubnVpdHlMb2FuKGlucHV0KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIGNhbGN1bGF0ZURpZmZlcmVudGlhdGVkTG9hbihpbnB1dCk7XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogRXhwb3J0IHBheW1lbnQgc2NoZWR1bGUgYXMgQ1NWXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0UGF5bWVudFNjaGVkdWxlVG9DU1YoXHJcblx0c2NoZWR1bGU6IFBheW1lbnRTY2hlZHVsZUl0ZW1bXVxyXG4pOiBzdHJpbmcge1xyXG5cdGNvbnN0IGhlYWRlcnMgPSBbJ01vbnRoJywgJ1BheW1lbnQnLCAnSW50ZXJlc3QnLCAnUHJpbmNpcGFsJywgJ0JhbGFuY2UnXTtcclxuXHRjb25zdCByb3dzID0gc2NoZWR1bGUubWFwKChpdGVtKSA9PiBbXHJcblx0XHRpdGVtLm1vbnRoLFxyXG5cdFx0aXRlbS5wYXltZW50LnRvRml4ZWQoMiksXHJcblx0XHRpdGVtLmludGVyZXN0LnRvRml4ZWQoMiksXHJcblx0XHRpdGVtLnByaW5jaXBhbC50b0ZpeGVkKDIpLFxyXG5cdFx0aXRlbS5iYWxhbmNlLnRvRml4ZWQoMiksXHJcblx0XSk7XHJcblxyXG5cdHJldHVybiBbaGVhZGVycywgLi4ucm93c10ubWFwKChyb3cpID0+IHJvdy5qb2luKCcsJykpLmpvaW4oJ1xcbicpO1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGUgbG9hbiBpbnB1dCBwYXJhbWV0ZXJzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMb2FuSW5wdXQoaW5wdXQ6IFBhcnRpYWw8TG9hbklucHV0Pik6IHN0cmluZ1tdIHtcclxuXHRjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdGlmICghaW5wdXQubG9hbkFtb3VudCB8fCBpbnB1dC5sb2FuQW1vdW50IDw9IDApIHtcclxuXHRcdGVycm9ycy5wdXNoKCdMb2FuIGFtb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XHJcblx0fVxyXG5cclxuXHQvLyBDYWxjdWxhdGUgdG90YWwgdGVybSBpbiBtb250aHMgZnJvbSB5ZWFycyBhbmQgbW9udGhzXHJcblx0Y29uc3QgdG90YWxUZXJtTW9udGhzID0gKGlucHV0LnRlcm1ZZWFycyB8fCAwKSAqIDEyICsgKGlucHV0LnRlcm1Nb250aHMgfHwgMCk7XHJcblx0XHJcblx0aWYgKHRvdGFsVGVybU1vbnRocyA8IDEgfHwgdG90YWxUZXJtTW9udGhzID4gMzYwKSB7XHJcblx0XHRlcnJvcnMucHVzaCgnTG9hbiB0ZXJtIG11c3QgYmUgYmV0d2VlbiAxIG1vbnRoIGFuZCAzMCB5ZWFycycpO1xyXG5cdH1cclxuXHJcblx0aWYgKFxyXG5cdFx0aW5wdXQuaW50ZXJlc3RSYXRlID09PSB1bmRlZmluZWQgfHxcclxuXHRcdGlucHV0LmludGVyZXN0UmF0ZSA8IDAgfHxcclxuXHRcdGlucHV0LmludGVyZXN0UmF0ZSA+IDEwMFxyXG5cdCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ0ludGVyZXN0IHJhdGUgbXVzdCBiZSBiZXR3ZWVuIDAlIGFuZCAxMDAlJyk7XHJcblx0fVxyXG5cclxuXHRpZiAoaW5wdXQuZG93blBheW1lbnQgJiYgaW5wdXQuZG93blBheW1lbnQgPCAwKSB7XHJcblx0XHRlcnJvcnMucHVzaCgnRG93biBwYXltZW50IGNhbm5vdCBiZSBuZWdhdGl2ZScpO1xyXG5cdH1cclxuXHJcblx0aWYgKGlucHV0LmRvd25QYXltZW50ICYmIGlucHV0LmRvd25QYXltZW50ID49IGlucHV0LmxvYW5BbW91bnQpIHtcclxuXHRcdGVycm9ycy5wdXNoKFxyXG5cdFx0XHQnRG93biBwYXltZW50IGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbG9hbiBhbW91bnQnXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0aWYgKGlucHV0LmFkZGl0aW9uYWxQYXltZW50ICYmIGlucHV0LmFkZGl0aW9uYWxQYXltZW50IDwgMCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ0FkZGl0aW9uYWwgcGF5bWVudCBjYW5ub3QgYmUgbmVnYXRpdmUnKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBlcnJvcnM7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNhbGN1bGF0ZUFubnVpdHlMb2FuIiwiaW5wdXQiLCJsb2FuQW1vdW50IiwidGVybU1vbnRocyIsImludGVyZXN0UmF0ZSIsImFkZGl0aW9uYWxQYXltZW50IiwibW9udGhseVJhdGUiLCJlZmZlY3RpdmVMb2FuQW1vdW50IiwiZG93blBheW1lbnQiLCJiYXNlTW9udGhseVBheW1lbnQiLCJNYXRoIiwicG93IiwidG90YWxNb250aGx5UGF5bWVudCIsInNjaGVkdWxlIiwiYmFsYW5jZSIsInRvdGFsUGF5bWVudHMiLCJ0b3RhbEludGVyZXN0IiwiZWZmZWN0aXZlVGVybSIsIm1vbnRoIiwiaW50ZXJlc3RQYXltZW50IiwicHJpbmNpcGFsUGF5bWVudCIsIm1pbiIsImFjdHVhbFBheW1lbnQiLCJwdXNoIiwicGF5bWVudCIsImludGVyZXN0IiwicHJpbmNpcGFsIiwibWF4IiwibW9udGhseVBheW1lbnQiLCJwYXltZW50U2NoZWR1bGUiLCJjYWxjdWxhdGVEaWZmZXJlbnRpYXRlZExvYW4iLCJiYXNlUHJpbmNpcGFsUGF5bWVudCIsImFkZGl0aW9uYWxQcmluY2lwYWwiLCJ0b3RhbFByaW5jaXBhbFBheW1lbnQiLCJ0b3RhbFBheW1lbnQiLCJmaXJzdFBheW1lbnQiLCJnZW5lcmF0ZVBheW1lbnRTY2hlZHVsZSIsInBheW1lbnRUeXBlIiwiY2FsY3VsYXRlTG9hbiIsImV4cG9ydFBheW1lbnRTY2hlZHVsZVRvQ1NWIiwiaGVhZGVycyIsInJvd3MiLCJtYXAiLCJpdGVtIiwidG9GaXhlZCIsInJvdyIsImpvaW4iLCJ2YWxpZGF0ZUxvYW5JbnB1dCIsImVycm9ycyIsInRvdGFsVGVybU1vbnRocyIsInRlcm1ZZWFycyIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/calculators/loan.ts\n"));

/***/ })

});