"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[locale]/calc/credit-loan/page",{

/***/ "(app-pages-browser)/./src/lib/calculators/loan.ts":
/*!*************************************!*\
  !*** ./src/lib/calculators/loan.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateAnnuityLoan: function() { return /* binding */ calculateAnnuityLoan; },\n/* harmony export */   calculateDifferentiatedLoan: function() { return /* binding */ calculateDifferentiatedLoan; },\n/* harmony export */   calculateLoan: function() { return /* binding */ calculateLoan; },\n/* harmony export */   exportPaymentScheduleToCSV: function() { return /* binding */ exportPaymentScheduleToCSV; },\n/* harmony export */   generatePaymentSchedule: function() { return /* binding */ generatePaymentSchedule; },\n/* harmony export */   validateLoanInput: function() { return /* binding */ validateLoanInput; }\n/* harmony export */ });\n/**\r\n * Loan calculation library for credit calculators\r\n * Supports both annuity and differentiated payment methods\r\n */ /**\r\n * Calculate annuity loan payments (fixed monthly payment)\r\n */ function calculateAnnuityLoan(input) {\n    const { loanAmount, termMonths, interestRate, additionalPayment = 0 } = input;\n    const monthlyRate = interestRate / 100 / 12;\n    const effectiveLoanAmount = loanAmount - (input.downPayment || 0);\n    // Calculate base monthly payment\n    const baseMonthlyPayment = monthlyRate === 0 ? effectiveLoanAmount / termMonths : effectiveLoanAmount * monthlyRate * Math.pow(1 + monthlyRate, termMonths) / (Math.pow(1 + monthlyRate, termMonths) - 1);\n    const totalMonthlyPayment = baseMonthlyPayment + additionalPayment;\n    // Calculate payment schedule\n    const schedule = [];\n    let balance = effectiveLoanAmount;\n    let totalPayments = 0;\n    let totalInterest = 0;\n    let effectiveTerm = 0;\n    for(let month = 1; month <= termMonths; month++){\n        const interestPayment = balance * monthlyRate;\n        const principalPayment = Math.min(totalMonthlyPayment - interestPayment, balance);\n        const actualPayment = principalPayment + interestPayment;\n        balance -= principalPayment;\n        totalPayments += actualPayment;\n        totalInterest += interestPayment;\n        effectiveTerm = month;\n        schedule.push({\n            month,\n            payment: actualPayment,\n            interest: interestPayment,\n            principal: principalPayment,\n            balance: Math.max(0, balance)\n        });\n        // If balance is paid off early due to additional payments\n        if (balance <= 0.01) {\n            break;\n        }\n    }\n    return {\n        monthlyPayment: totalMonthlyPayment,\n        totalPayments,\n        totalInterest,\n        effectiveTerm,\n        paymentSchedule: schedule\n    };\n}\n/**\r\n * Calculate differentiated loan payments (decreasing monthly payment)\r\n */ function calculateDifferentiatedLoan(input) {\n    var _schedule_;\n    const { loanAmount, termMonths, interestRate, additionalPayment = 0 } = input;\n    const monthlyRate = interestRate / 100 / 12;\n    const effectiveLoanAmount = loanAmount - (input.downPayment || 0);\n    const basePrincipalPayment = effectiveLoanAmount / termMonths;\n    // Calculate payment schedule\n    const schedule = [];\n    let balance = effectiveLoanAmount;\n    let totalPayments = 0;\n    let totalInterest = 0;\n    let effectiveTerm = 0;\n    for(let month = 1; month <= termMonths; month++){\n        const interestPayment = balance * monthlyRate;\n        const principalPayment = Math.min(basePrincipalPayment, balance);\n        const additionalPrincipal = Math.min(additionalPayment, balance - principalPayment);\n        const totalPrincipalPayment = principalPayment + additionalPrincipal;\n        const totalPayment = totalPrincipalPayment + interestPayment;\n        balance -= totalPrincipalPayment;\n        totalPayments += totalPayment;\n        totalInterest += interestPayment;\n        effectiveTerm = month;\n        schedule.push({\n            month,\n            payment: totalPayment,\n            interest: interestPayment,\n            principal: totalPrincipalPayment,\n            balance: Math.max(0, balance)\n        });\n        // If balance is paid off early due to additional payments\n        if (balance <= 0.01) {\n            break;\n        }\n    }\n    // First payment is the highest for differentiated loans\n    const firstPayment = ((_schedule_ = schedule[0]) === null || _schedule_ === void 0 ? void 0 : _schedule_.payment) || 0;\n    return {\n        monthlyPayment: firstPayment,\n        totalPayments,\n        totalInterest,\n        effectiveTerm,\n        paymentSchedule: schedule\n    };\n}\n/**\r\n * Generate payment schedule for both loan types\r\n */ function generatePaymentSchedule(input) {\n    if (input.paymentType === \"annuity\") {\n        return calculateAnnuityLoan(input).paymentSchedule;\n    } else {\n        return calculateDifferentiatedLoan(input).paymentSchedule;\n    }\n}\n/**\r\n * Calculate loan with specified payment type\r\n */ function calculateLoan(input) {\n    if (input.paymentType === \"annuity\") {\n        return calculateAnnuityLoan(input);\n    } else {\n        return calculateDifferentiatedLoan(input);\n    }\n}\n/**\r\n * Export payment schedule as CSV\r\n */ function exportPaymentScheduleToCSV(schedule) {\n    const headers = [\n        \"Month\",\n        \"Payment\",\n        \"Interest\",\n        \"Principal\",\n        \"Balance\"\n    ];\n    const rows = schedule.map((item)=>[\n            item.month,\n            item.payment.toFixed(2),\n            item.interest.toFixed(2),\n            item.principal.toFixed(2),\n            item.balance.toFixed(2)\n        ]);\n    return [\n        headers,\n        ...rows\n    ].map((row)=>row.join(\",\")).join(\"\\n\");\n}\n/**\r\n * Validate loan input parameters\r\n */ function validateLoanInput(input) {\n    const errors = [];\n    if (!input.loanAmount || input.loanAmount <= 0) {\n        errors.push(\"Loan amount must be greater than 0\");\n    }\n    // Calculate total term in months from years and months\n    const totalTermMonths = (input.termYears || 0) * 12 + (input.termMonths || 0);\n    if (totalTermMonths < 1 || totalTermMonths > 360) {\n        errors.push(\"Loan term must be between 1 month and 30 years\");\n    }\n    if (input.interestRate === undefined || input.interestRate < 0 || input.interestRate > 100) {\n        errors.push(\"Interest rate must be between 0% and 100%\");\n    }\n    if (input.downPayment && input.downPayment < 0) {\n        errors.push(\"Down payment cannot be negative\");\n    }\n    if (input.downPayment && input.downPayment >= input.loanAmount) {\n        errors.push(\"Down payment cannot be greater than or equal to loan amount\");\n    }\n    if (input.additionalPayment && input.additionalPayment < 0) {\n        errors.push(\"Additional payment cannot be negative\");\n    }\n    return errors;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY2FsY3VsYXRvcnMvbG9hbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0E0QkQ7O0NBRUMsR0FDTSxTQUFTQSxxQkFBcUJDLEtBQWdCO0lBQ3BELE1BQU0sRUFDTEMsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLFlBQVksRUFDWkMsb0JBQW9CLENBQUMsRUFDckIsR0FBR0o7SUFDSixNQUFNSyxjQUFjRixlQUFlLE1BQU07SUFDekMsTUFBTUcsc0JBQXNCTCxhQUFjRCxDQUFBQSxNQUFNTyxXQUFXLElBQUk7SUFFL0QsaUNBQWlDO0lBQ2pDLE1BQU1DLHFCQUNMSCxnQkFBZ0IsSUFDYkMsc0JBQXNCSixhQUN0QixzQkFDQUcsY0FDQUksS0FBS0MsR0FBRyxDQUFDLElBQUlMLGFBQWFILGNBQ3pCTyxDQUFBQSxLQUFLQyxHQUFHLENBQUMsSUFBSUwsYUFBYUgsY0FBYztJQUU3QyxNQUFNUyxzQkFBc0JILHFCQUFxQko7SUFFakQsNkJBQTZCO0lBQzdCLE1BQU1RLFdBQWtDLEVBQUU7SUFDMUMsSUFBSUMsVUFBVVA7SUFDZCxJQUFJUSxnQkFBZ0I7SUFDcEIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUlDLGdCQUFnQjtJQUVwQixJQUFLLElBQUlDLFFBQVEsR0FBR0EsU0FBU2YsWUFBWWUsUUFBUztRQUNqRCxNQUFNQyxrQkFBa0JMLFVBQVVSO1FBQ2xDLE1BQU1jLG1CQUFtQlYsS0FBS1csR0FBRyxDQUNoQ1Qsc0JBQXNCTyxpQkFDdEJMO1FBRUQsTUFBTVEsZ0JBQWdCRixtQkFBbUJEO1FBRXpDTCxXQUFXTTtRQUNYTCxpQkFBaUJPO1FBQ2pCTixpQkFBaUJHO1FBQ2pCRixnQkFBZ0JDO1FBRWhCTCxTQUFTVSxJQUFJLENBQUM7WUFDYkw7WUFDQU0sU0FBU0Y7WUFDVEcsVUFBVU47WUFDVk8sV0FBV047WUFDWE4sU0FBU0osS0FBS2lCLEdBQUcsQ0FBQyxHQUFHYjtRQUN0QjtRQUVBLDBEQUEw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QUFJLENBQUMvQyxNQUFNQyxVQUFVLElBQUlELE1BQU1DLFVBQVUsSUFBSSxHQUFHO1FBQy9DOEMsT0FBT3pCLElBQUksQ0FBQztJQUNiO0lBRUEsdURBQXVEO0lBQ3ZELE1BQU0wQixrQkFDTCxDQUFDaEQsTUFBTWlELFNBQVMsSUFBSSxLQUFLLEtBQU1qRCxDQUFBQSxNQUFNRSxVQUFVLElBQUk7SUFFcEQsSUFBSThDLGtCQUFrQixLQUFLQSxrQkFBa0IsS0FBSztRQUNqREQsT0FBT3pCLElBQUksQ0FBQztJQUNiO0lBRUEsSUFDQ3RCLE1BQU1HLFlBQVksS0FBSytDLGFBQ3ZCbEQsTUFBTUcsWUFBWSxHQUFHLEtBQ3JCSCxNQUFNRyxZQUFZLEdBQUcsS0FDcEI7UUFDRDRDLE9BQU96QixJQUFJLENBQUM7SUFDYjtJQUVBLElBQUl0QixNQUFNTyxXQUFXLElBQUlQLE1BQU1PLFdBQVcsR0FBRyxHQUFHO1FBQy9Dd0MsT0FBT3pCLElBQUksQ0FBQztJQUNiO0lBRUEsSUFBSXRCLE1BQU1PLFdBQVcsSUFBSVAsTUFBTU8sV0FBVyxJQUFJUCxNQUFNQyxVQUFVLEVBQUU7UUFDL0Q4QyxPQUFPekIsSUFBSSxDQUNWO0lBRUY7SUFFQSxJQUFJdEIsTUFBTUksaUJBQWlCLElBQUlKLE1BQU1JLGlCQUFpQixHQUFHLEdBQUc7UUFDM0QyQyxPQUFPekIsSUFBSSxDQUFDO0lBQ2I7SUFFQSxPQUFPeUI7QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2NhbGN1bGF0b3JzL2xvYW4udHM/MDkyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTG9hbiBjYWxjdWxhdGlvbiBsaWJyYXJ5IGZvciBjcmVkaXQgY2FsY3VsYXRvcnNcclxuICogU3VwcG9ydHMgYm90aCBhbm51aXR5IGFuZCBkaWZmZXJlbnRpYXRlZCBwYXltZW50IG1ldGhvZHNcclxuICovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIExvYW5JbnB1dCB7XHJcblx0bG9hbkFtb3VudDogbnVtYmVyO1xyXG5cdHRlcm1ZZWFyczogbnVtYmVyO1xyXG5cdHRlcm1Nb250aHM6IG51bWJlcjtcclxuXHRpbnRlcmVzdFJhdGU6IG51bWJlcjtcclxuXHRkb3duUGF5bWVudD86IG51bWJlcjtcclxuXHRhZGRpdGlvbmFsUGF5bWVudD86IG51bWJlcjtcclxuXHRwYXltZW50VHlwZTogJ2FubnVpdHknIHwgJ2RpZmZlcmVudGlhdGVkJztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQYXltZW50U2NoZWR1bGVJdGVtIHtcclxuXHRtb250aDogbnVtYmVyO1xyXG5cdHBheW1lbnQ6IG51bWJlcjtcclxuXHRpbnRlcmVzdDogbnVtYmVyO1xyXG5cdHByaW5jaXBhbDogbnVtYmVyO1xyXG5cdGJhbGFuY2U6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMb2FuUmVzdWx0IHtcclxuXHRtb250aGx5UGF5bWVudDogbnVtYmVyO1xyXG5cdHRvdGFsUGF5bWVudHM6IG51bWJlcjtcclxuXHR0b3RhbEludGVyZXN0OiBudW1iZXI7XHJcblx0ZWZmZWN0aXZlVGVybTogbnVtYmVyO1xyXG5cdHBheW1lbnRTY2hlZHVsZTogUGF5bWVudFNjaGVkdWxlSXRlbVtdO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIGFubnVpdHkgbG9hbiBwYXltZW50cyAoZml4ZWQgbW9udGhseSBwYXltZW50KVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUFubnVpdHlMb2FuKGlucHV0OiBMb2FuSW5wdXQpOiBMb2FuUmVzdWx0IHtcclxuXHRjb25zdCB7XHJcblx0XHRsb2FuQW1vdW50LFxyXG5cdFx0dGVybU1vbnRocyxcclxuXHRcdGludGVyZXN0UmF0ZSxcclxuXHRcdGFkZGl0aW9uYWxQYXltZW50ID0gMCxcclxuXHR9ID0gaW5wdXQ7XHJcblx0Y29uc3QgbW9udGhseVJhdGUgPSBpbnRlcmVzdFJhdGUgLyAxMDAgLyAxMjtcclxuXHRjb25zdCBlZmZlY3RpdmVMb2FuQW1vdW50ID0gbG9hbkFtb3VudCAtIChpbnB1dC5kb3duUGF5bWVudCB8fCAwKTtcclxuXHJcblx0Ly8gQ2FsY3VsYXRlIGJhc2UgbW9udGhseSBwYXltZW50XHJcblx0Y29uc3QgYmFzZU1vbnRobHlQYXltZW50ID1cclxuXHRcdG1vbnRobHlSYXRlID09PSAwXHJcblx0XHRcdD8gZWZmZWN0aXZlTG9hbkFtb3VudCAvIHRlcm1Nb250aHNcclxuXHRcdFx0OiAoZWZmZWN0aXZlTG9hbkFtb3VudCAqXHJcblx0XHRcdFx0XHRtb250aGx5UmF0ZSAqXHJcblx0XHRcdFx0XHRNYXRoLnBvdygxICsgbW9udGhseVJhdGUsIHRlcm1Nb250aHMpKSAvXHJcblx0XHRcdCAgKE1hdGgucG93KDEgKyBtb250aGx5UmF0ZSwgdGVybU1vbnRocykgLSAxKTtcclxuXHJcblx0Y29uc3QgdG90YWxNb250aGx5UGF5bWVudCA9IGJhc2VNb250aGx5UGF5bWVudCArIGFkZGl0aW9uYWxQYXltZW50O1xyXG5cclxuXHQvLyBDYWxjdWxhdGUgcGF5bWVudCBzY2hlZHVsZVxyXG5cdGNvbnN0IHNjaGVkdWxlOiBQYXltZW50U2NoZWR1bGVJdGVtW10gPSBbXTtcclxuXHRsZXQgYmFsYW5jZSA9IGVmZmVjdGl2ZUxvYW5BbW91bnQ7XHJcblx0bGV0IHRvdGFsUGF5bWVudHMgPSAwO1xyXG5cdGxldCB0b3RhbEludGVyZXN0ID0gMDtcclxuXHRsZXQgZWZmZWN0aXZlVGVybSA9IDA7XHJcblxyXG5cdGZvciAobGV0IG1vbnRoID0gMTsgbW9udGggPD0gdGVybU1vbnRoczsgbW9udGgrKykge1xyXG5cdFx0Y29uc3QgaW50ZXJlc3RQYXltZW50ID0gYmFsYW5jZSAqIG1vbnRobHlSYXRlO1xyXG5cdFx0Y29uc3QgcHJpbmNpcGFsUGF5bWVudCA9IE1hdGgubWluKFxyXG5cdFx0XHR0b3RhbE1vbnRobHlQYXltZW50IC0gaW50ZXJlc3RQYXltZW50LFxyXG5cdFx0XHRiYWxhbmNlXHJcblx0XHQpO1xyXG5cdFx0Y29uc3QgYWN0dWFsUGF5bWVudCA9IHByaW5jaXBhbFBheW1lbnQgKyBpbnRlcmVzdFBheW1lbnQ7XHJcblxyXG5cdFx0YmFsYW5jZSAtPSBwcmluY2lwYWxQYXltZW50O1xyXG5cdFx0dG90YWxQYXltZW50cyArPSBhY3R1YWxQYXltZW50O1xyXG5cdFx0dG90YWxJbnRlcmVzdCArPSBpbnRlcmVzdFBheW1lbnQ7XHJcblx0XHRlZmZlY3RpdmVUZXJtID0gbW9udGg7XHJcblxyXG5cdFx0c2NoZWR1bGUucHVzaCh7XHJcblx0XHRcdG1vbnRoLFxyXG5cdFx0XHRwYXltZW50OiBhY3R1YWxQYXltZW50LFxyXG5cdFx0XHRpbnRlcmVzdDogaW50ZXJlc3RQYXltZW50LFxyXG5cdFx0XHRwcmluY2lwYWw6IHByaW5jaXBhbFBheW1lbnQsXHJcblx0XHRcdGJhbGFuY2U6IE1hdGgubWF4KDAsIGJhbGFuY2UpLFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gSWYgYmFsYW5jZSBpcyBwYWlkIG9mZiBlYXJseSBkdWUgdG8gYWRkaXRpb25hbCBwYXltZW50c1xyXG5cdFx0aWYgKGJhbGFuY2UgPD0gMC4wMSkge1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRtb250aGx5UGF5bWVudDogdG90YWxNb250aGx5UGF5bWVudCxcclxuXHRcdHRvdGFsUGF5bWVudHMsXHJcblx0XHR0b3RhbEludGVyZXN0LFxyXG5cdFx0ZWZmZWN0aXZlVGVybSxcclxuXHRcdHBheW1lbnRTY2hlZHVsZTogc2NoZWR1bGUsXHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBkaWZmZXJlbnRpYXRlZCBsb2FuIHBheW1lbnRzIChkZWNyZWFzaW5nIG1vbnRobHkgcGF5bWVudClcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEaWZmZXJlbnRpYXRlZExvYW4oaW5wdXQ6IExvYW5JbnB1dCk6IExvYW5SZXN1bHQge1xyXG5cdGNvbnN0IHtcclxuXHRcdGxvYW5BbW91bnQsXHJcblx0XHR0ZXJtTW9udGhzLFxyXG5cdFx0aW50ZXJlc3RSYXRlLFxyXG5cdFx0YWRkaXRpb25hbFBheW1lbnQgPSAwLFxyXG5cdH0gPSBpbnB1dDtcclxuXHRjb25zdCBtb250aGx5UmF0ZSA9IGludGVyZXN0UmF0ZSAvIDEwMCAvIDEyO1xyXG5cdGNvbnN0IGVmZmVjdGl2ZUxvYW5BbW91bnQgPSBsb2FuQW1vdW50IC0gKGlucHV0LmRvd25QYXltZW50IHx8IDApO1xyXG5cdGNvbnN0IGJhc2VQcmluY2lwYWxQYXltZW50ID0gZWZmZWN0aXZlTG9hbkFtb3VudCAvIHRlcm1Nb250aHM7XHJcblxyXG5cdC8vIENhbGN1bGF0ZSBwYXltZW50IHNjaGVkdWxlXHJcblx0Y29uc3Qgc2NoZWR1bGU6IFBheW1lbnRTY2hlZHVsZUl0ZW1bXSA9IFtdO1xyXG5cdGxldCBiYWxhbmNlID0gZWZmZWN0aXZlTG9hbkFtb3VudDtcclxuXHRsZXQgdG90YWxQYXltZW50cyA9IDA7XHJcblx0bGV0IHRvdGFsSW50ZXJlc3QgPSAwO1xyXG5cdGxldCBlZmZlY3RpdmVUZXJtID0gMDtcclxuXHJcblx0Zm9yIChsZXQgbW9udGggPSAxOyBtb250aCA8PSB0ZXJtTW9udGhzOyBtb250aCsrKSB7XHJcblx0XHRjb25zdCBpbnRlcmVzdFBheW1lbnQgPSBiYWxhbmNlICogbW9udGhseVJhdGU7XHJcblx0XHRjb25zdCBwcmluY2lwYWxQYXltZW50ID0gTWF0aC5taW4oYmFzZVByaW5jaXBhbFBheW1lbnQsIGJhbGFuY2UpO1xyXG5cdFx0Y29uc3QgYWRkaXRpb25hbFByaW5jaXBhbCA9IE1hdGgubWluKFxyXG5cdFx0XHRhZGRpdGlvbmFsUGF5bWVudCxcclxuXHRcdFx0YmFsYW5jZSAtIHByaW5jaXBhbFBheW1lbnRcclxuXHRcdCk7XHJcblx0XHRjb25zdCB0b3RhbFByaW5jaXBhbFBheW1lbnQgPSBwcmluY2lwYWxQYXltZW50ICsgYWRkaXRpb25hbFByaW5jaXBhbDtcclxuXHRcdGNvbnN0IHRvdGFsUGF5bWVudCA9IHRvdGFsUHJpbmNpcGFsUGF5bWVudCArIGludGVyZXN0UGF5bWVudDtcclxuXHJcblx0XHRiYWxhbmNlIC09IHRvdGFsUHJpbmNpcGFsUGF5bWVudDtcclxuXHRcdHRvdGFsUGF5bWVudHMgKz0gdG90YWxQYXltZW50O1xyXG5cdFx0dG90YWxJbnRlcmVzdCArPSBpbnRlcmVzdFBheW1lbnQ7XHJcblx0XHRlZmZlY3RpdmVUZXJtID0gbW9udGg7XHJcblxyXG5cdFx0c2NoZWR1bGUucHVzaCh7XHJcblx0XHRcdG1vbnRoLFxyXG5cdFx0XHRwYXltZW50OiB0b3RhbFBheW1lbnQsXHJcblx0XHRcdGludGVyZXN0OiBpbnRlcmVzdFBheW1lbnQsXHJcblx0XHRcdHByaW5jaXBhbDogdG90YWxQcmluY2lwYWxQYXltZW50LFxyXG5cdFx0XHRiYWxhbmNlOiBNYXRoLm1heCgwLCBiYWxhbmNlKSxcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIElmIGJhbGFuY2UgaXMgcGFpZCBvZmYgZWFybHkgZHVlIHRvIGFkZGl0aW9uYWwgcGF5bWVudHNcclxuXHRcdGlmIChiYWxhbmNlIDw9IDAuMDEpIHtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBGaXJzdCBwYXltZW50IGlzIHRoZSBoaWdoZXN0IGZvciBkaWZmZXJlbnRpYXRlZCBsb2Fuc1xyXG5cdGNvbnN0IGZpcnN0UGF5bWVudCA9IHNjaGVkdWxlWzBdPy5wYXltZW50IHx8IDA7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRtb250aGx5UGF5bWVudDogZmlyc3RQYXltZW50LFxyXG5cdFx0dG90YWxQYXltZW50cyxcclxuXHRcdHRvdGFsSW50ZXJlc3QsXHJcblx0XHRlZmZlY3RpdmVUZXJtLFxyXG5cdFx0cGF5bWVudFNjaGVkdWxlOiBzY2hlZHVsZSxcclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgcGF5bWVudCBzY2hlZHVsZSBmb3IgYm90aCBsb2FuIHR5cGVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYXltZW50U2NoZWR1bGUoXHJcblx0aW5wdXQ6IExvYW5JbnB1dFxyXG4pOiBQYXltZW50U2NoZWR1bGVJdGVtW10ge1xyXG5cdGlmIChpbnB1dC5wYXltZW50VHlwZSA9PT0gJ2FubnVpdHknKSB7XHJcblx0XHRyZXR1cm4gY2FsY3VsYXRlQW5udWl0eUxvYW4oaW5wdXQpLnBheW1lbnRTY2hlZHVsZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIGNhbGN1bGF0ZURpZmZlcmVudGlhdGVkTG9hbihpbnB1dCkucGF5bWVudFNjaGVkdWxlO1xyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBsb2FuIHdpdGggc3BlY2lmaWVkIHBheW1lbnQgdHlwZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUxvYW4oaW5wdXQ6IExvYW5JbnB1dCk6IExvYW5SZXN1bHQge1xyXG5cdGlmIChpbnB1dC5wYXltZW50VHlwZSA9PT0gJ2FubnVpdHknKSB7XHJcblx0XHRyZXR1cm4gY2FsY3VsYXRlQW5udWl0eUxvYW4oaW5wdXQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gY2FsY3VsYXRlRGlmZmVyZW50aWF0ZWRMb2FuKGlucHV0KTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHBvcnQgcGF5bWVudCBzY2hlZHVsZSBhcyBDU1ZcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRQYXltZW50U2NoZWR1bGVUb0NTVihcclxuXHRzY2hlZHVsZTogUGF5bWVudFNjaGVkdWxlSXRlbVtdXHJcbik6IHN0cmluZyB7XHJcblx0Y29uc3QgaGVhZGVycyA9IFsnTW9udGgnLCAnUGF5bWVudCcsICdJbnRlcmVzdCcsICdQcmluY2lwYWwnLCAnQmFsYW5jZSddO1xyXG5cdGNvbnN0IHJvd3MgPSBzY2hlZHVsZS5tYXAoKGl0ZW0pID0+IFtcclxuXHRcdGl0ZW0ubW9udGgsXHJcblx0XHRpdGVtLnBheW1lbnQudG9GaXhlZCgyKSxcclxuXHRcdGl0ZW0uaW50ZXJlc3QudG9GaXhlZCgyKSxcclxuXHRcdGl0ZW0ucHJpbmNpcGFsLnRvRml4ZWQoMiksXHJcblx0XHRpdGVtLmJhbGFuY2UudG9GaXhlZCgyKSxcclxuXHRdKTtcclxuXHJcblx0cmV0dXJuIFtoZWFkZXJzLCAuLi5yb3dzXS5tYXAoKHJvdykgPT4gcm93LmpvaW4oJywnKSkuam9pbignXFxuJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBsb2FuIGlucHV0IHBhcmFtZXRlcnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUxvYW5JbnB1dChpbnB1dDogUGFydGlhbDxMb2FuSW5wdXQ+KTogc3RyaW5nW10ge1xyXG5cdGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcclxuXHJcblx0aWYgKCFpbnB1dC5sb2FuQW1vdW50IHx8IGlucHV0LmxvYW5BbW91bnQgPD0gMCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ0xvYW4gYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcclxuXHR9XHJcblxyXG5cdC8vIENhbGN1bGF0ZSB0b3RhbCB0ZXJtIGluIG1vbnRocyBmcm9tIHllYXJzIGFuZCBtb250aHNcclxuXHRjb25zdCB0b3RhbFRlcm1Nb250aHMgPVxyXG5cdFx0KGlucHV0LnRlcm1ZZWFycyB8fCAwKSAqIDEyICsgKGlucHV0LnRlcm1Nb250aHMgfHwgMCk7XHJcblxyXG5cdGlmICh0b3RhbFRlcm1Nb250aHMgPCAxIHx8IHRvdGFsVGVybU1vbnRocyA+IDM2MCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ0xvYW4gdGVybSBtdXN0IGJlIGJldHdlZW4gMSBtb250aCBhbmQgMzAgeWVhcnMnKTtcclxuXHR9XHJcblxyXG5cdGlmIChcclxuXHRcdGlucHV0LmludGVyZXN0UmF0ZSA9PT0gdW5kZWZpbmVkIHx8XHJcblx0XHRpbnB1dC5pbnRlcmVzdFJhdGUgPCAwIHx8XHJcblx0XHRpbnB1dC5pbnRlcmVzdFJhdGUgPiAxMDBcclxuXHQpIHtcclxuXHRcdGVycm9ycy5wdXNoKCdJbnRlcmVzdCByYXRlIG11c3QgYmUgYmV0d2VlbiAwJSBhbmQgMTAwJScpO1xyXG5cdH1cclxuXHJcblx0aWYgKGlucHV0LmRvd25QYXltZW50ICYmIGlucHV0LmRvd25QYXltZW50IDwgMCkge1xyXG5cdFx0ZXJyb3JzLnB1c2goJ0Rvd24gcGF5bWVudCBjYW5ub3QgYmUgbmVnYXRpdmUnKTtcclxuXHR9XHJcblxyXG5cdGlmIChpbnB1dC5kb3duUGF5bWVudCAmJiBpbnB1dC5kb3duUGF5bWVudCA+PSBpbnB1dC5sb2FuQW1vdW50KSB7XHJcblx0XHRlcnJvcnMucHVzaChcclxuXHRcdFx0J0Rvd24gcGF5bWVudCBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGxvYW4gYW1vdW50J1xyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdGlmIChpbnB1dC5hZGRpdGlvbmFsUGF5bWVudCAmJiBpbnB1dC5hZGRpdGlvbmFsUGF5bWVudCA8IDApIHtcclxuXHRcdGVycm9ycy5wdXNoKCdBZGRpdGlvbmFsIHBheW1lbnQgY2Fubm90IGJlIG5lZ2F0aXZlJyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZXJyb3JzO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVBbm51aXR5TG9hbiIsImlucHV0IiwibG9hbkFtb3VudCIsInRlcm1Nb250aHMiLCJpbnRlcmVzdFJhdGUiLCJhZGRpdGlvbmFsUGF5bWVudCIsIm1vbnRobHlSYXRlIiwiZWZmZWN0aXZlTG9hbkFtb3VudCIsImRvd25QYXltZW50IiwiYmFzZU1vbnRobHlQYXltZW50IiwiTWF0aCIsInBvdyIsInRvdGFsTW9udGhseVBheW1lbnQiLCJzY2hlZHVsZSIsImJhbGFuY2UiLCJ0b3RhbFBheW1lbnRzIiwidG90YWxJbnRlcmVzdCIsImVmZmVjdGl2ZVRlcm0iLCJtb250aCIsImludGVyZXN0UGF5bWVudCIsInByaW5jaXBhbFBheW1lbnQiLCJtaW4iLCJhY3R1YWxQYXltZW50IiwicHVzaCIsInBheW1lbnQiLCJpbnRlcmVzdCIsInByaW5jaXBhbCIsIm1heCIsIm1vbnRobHlQYXltZW50IiwicGF5bWVudFNjaGVkdWxlIiwiY2FsY3VsYXRlRGlmZmVyZW50aWF0ZWRMb2FuIiwiYmFzZVByaW5jaXBhbFBheW1lbnQiLCJhZGRpdGlvbmFsUHJpbmNpcGFsIiwidG90YWxQcmluY2lwYWxQYXltZW50IiwidG90YWxQYXltZW50IiwiZmlyc3RQYXltZW50IiwiZ2VuZXJhdGVQYXltZW50U2NoZWR1bGUiLCJwYXltZW50VHlwZSIsImNhbGN1bGF0ZUxvYW4iLCJleHBvcnRQYXltZW50U2NoZWR1bGVUb0NTViIsImhlYWRlcnMiLCJyb3dzIiwibWFwIiwiaXRlbSIsInRvRml4ZWQiLCJyb3ciLCJqb2luIiwidmFsaWRhdGVMb2FuSW5wdXQiLCJlcnJvcnMiLCJ0b3RhbFRlcm1Nb250aHMiLCJ0ZXJtWWVhcnMiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/calculators/loan.ts\n"));

/***/ })

});